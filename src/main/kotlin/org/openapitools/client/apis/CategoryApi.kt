/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountConfigUpdate200Response
import org.openapitools.client.models.AttributeDelete200Response
import org.openapitools.client.models.CartConfigUpdate200Response
import org.openapitools.client.models.CategoryAdd200Response
import org.openapitools.client.models.CategoryAddBatch
import org.openapitools.client.models.CategoryAddBatch200Response
import org.openapitools.client.models.CategoryCount200Response
import org.openapitools.client.models.CategoryDelete200Response
import org.openapitools.client.models.CategoryFind200Response
import org.openapitools.client.models.CategoryImageAdd200Response
import org.openapitools.client.models.CategoryInfo200Response
import org.openapitools.client.models.ModelResponseCategoryList

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class CategoryApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.api2cart.com/v1.1")
        }
    }

    /**
     * category.add
     * Add new category in store
     * @param name Defines category&#39;s name that has to be added
     * @param parentId Adds categories specified by parent id (optional)
     * @param storesIds Create category in the stores that is specified by comma-separated stores&#39; id (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param sortOrder Sort number in the list (optional, default to 0)
     * @param createdTime Entity&#39;s date creation (optional)
     * @param modifiedTime Entity&#39;s date modification (optional)
     * @param description Defines category&#39;s description (optional)
     * @param shortDescription Defines short description (optional)
     * @param metaTitle Defines unique meta title for each entity (optional)
     * @param metaDescription Defines unique meta description of a entity (optional)
     * @param metaKeywords Defines unique meta keywords for each entity (optional)
     * @param seoUrl Defines unique category&#39;s URL for SEO (optional)
     * @return CategoryAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryAdd(name: kotlin.String, parentId: kotlin.String? = null, storesIds: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, avail: kotlin.Boolean? = true, sortOrder: kotlin.Int? = 0, createdTime: kotlin.String? = null, modifiedTime: kotlin.String? = null, description: kotlin.String? = null, shortDescription: kotlin.String? = null, metaTitle: kotlin.String? = null, metaDescription: kotlin.String? = null, metaKeywords: kotlin.String? = null, seoUrl: kotlin.String? = null) : CategoryAdd200Response {
        val localVarResponse = categoryAddWithHttpInfo(name = name, parentId = parentId, storesIds = storesIds, storeId = storeId, langId = langId, avail = avail, sortOrder = sortOrder, createdTime = createdTime, modifiedTime = modifiedTime, description = description, shortDescription = shortDescription, metaTitle = metaTitle, metaDescription = metaDescription, metaKeywords = metaKeywords, seoUrl = seoUrl)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.add
     * Add new category in store
     * @param name Defines category&#39;s name that has to be added
     * @param parentId Adds categories specified by parent id (optional)
     * @param storesIds Create category in the stores that is specified by comma-separated stores&#39; id (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param sortOrder Sort number in the list (optional, default to 0)
     * @param createdTime Entity&#39;s date creation (optional)
     * @param modifiedTime Entity&#39;s date modification (optional)
     * @param description Defines category&#39;s description (optional)
     * @param shortDescription Defines short description (optional)
     * @param metaTitle Defines unique meta title for each entity (optional)
     * @param metaDescription Defines unique meta description of a entity (optional)
     * @param metaKeywords Defines unique meta keywords for each entity (optional)
     * @param seoUrl Defines unique category&#39;s URL for SEO (optional)
     * @return ApiResponse<CategoryAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryAddWithHttpInfo(name: kotlin.String, parentId: kotlin.String?, storesIds: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, avail: kotlin.Boolean?, sortOrder: kotlin.Int?, createdTime: kotlin.String?, modifiedTime: kotlin.String?, description: kotlin.String?, shortDescription: kotlin.String?, metaTitle: kotlin.String?, metaDescription: kotlin.String?, metaKeywords: kotlin.String?, seoUrl: kotlin.String?) : ApiResponse<CategoryAdd200Response?> {
        val localVariableConfig = categoryAddRequestConfig(name = name, parentId = parentId, storesIds = storesIds, storeId = storeId, langId = langId, avail = avail, sortOrder = sortOrder, createdTime = createdTime, modifiedTime = modifiedTime, description = description, shortDescription = shortDescription, metaTitle = metaTitle, metaDescription = metaDescription, metaKeywords = metaKeywords, seoUrl = seoUrl)

        return request<Unit, CategoryAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryAdd
     *
     * @param name Defines category&#39;s name that has to be added
     * @param parentId Adds categories specified by parent id (optional)
     * @param storesIds Create category in the stores that is specified by comma-separated stores&#39; id (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param sortOrder Sort number in the list (optional, default to 0)
     * @param createdTime Entity&#39;s date creation (optional)
     * @param modifiedTime Entity&#39;s date modification (optional)
     * @param description Defines category&#39;s description (optional)
     * @param shortDescription Defines short description (optional)
     * @param metaTitle Defines unique meta title for each entity (optional)
     * @param metaDescription Defines unique meta description of a entity (optional)
     * @param metaKeywords Defines unique meta keywords for each entity (optional)
     * @param seoUrl Defines unique category&#39;s URL for SEO (optional)
     * @return RequestConfig
     */
    fun categoryAddRequestConfig(name: kotlin.String, parentId: kotlin.String?, storesIds: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, avail: kotlin.Boolean?, sortOrder: kotlin.Int?, createdTime: kotlin.String?, modifiedTime: kotlin.String?, description: kotlin.String?, shortDescription: kotlin.String?, metaTitle: kotlin.String?, metaDescription: kotlin.String?, metaKeywords: kotlin.String?, seoUrl: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("name", listOf(name.toString()))
                if (parentId != null) {
                    put("parent_id", listOf(parentId.toString()))
                }
                if (storesIds != null) {
                    put("stores_ids", listOf(storesIds.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
                if (sortOrder != null) {
                    put("sort_order", listOf(sortOrder.toString()))
                }
                if (createdTime != null) {
                    put("created_time", listOf(createdTime.toString()))
                }
                if (modifiedTime != null) {
                    put("modified_time", listOf(modifiedTime.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (shortDescription != null) {
                    put("short_description", listOf(shortDescription.toString()))
                }
                if (metaTitle != null) {
                    put("meta_title", listOf(metaTitle.toString()))
                }
                if (metaDescription != null) {
                    put("meta_description", listOf(metaDescription.toString()))
                }
                if (metaKeywords != null) {
                    put("meta_keywords", listOf(metaKeywords.toString()))
                }
                if (seoUrl != null) {
                    put("seo_url", listOf(seoUrl.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/category.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.add.batch
     * Add new categories to the store.
     * @param categoryAddBatch 
     * @return CategoryAddBatch200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryAddBatch(categoryAddBatch: CategoryAddBatch) : CategoryAddBatch200Response {
        val localVarResponse = categoryAddBatchWithHttpInfo(categoryAddBatch = categoryAddBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryAddBatch200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.add.batch
     * Add new categories to the store.
     * @param categoryAddBatch 
     * @return ApiResponse<CategoryAddBatch200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryAddBatchWithHttpInfo(categoryAddBatch: CategoryAddBatch) : ApiResponse<CategoryAddBatch200Response?> {
        val localVariableConfig = categoryAddBatchRequestConfig(categoryAddBatch = categoryAddBatch)

        return request<CategoryAddBatch, CategoryAddBatch200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryAddBatch
     *
     * @param categoryAddBatch 
     * @return RequestConfig
     */
    fun categoryAddBatchRequestConfig(categoryAddBatch: CategoryAddBatch) : RequestConfig<CategoryAddBatch> {
        val localVariableBody = categoryAddBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/category.add.batch.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.assign
     * Assign category to product
     * @param productId Defines category assign to the product, specified by product id
     * @param categoryId Defines category assign, specified by category id
     * @param storeId Store Id (optional)
     * @return CartConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryAssign(productId: kotlin.String, categoryId: kotlin.String, storeId: kotlin.String? = null) : CartConfigUpdate200Response {
        val localVarResponse = categoryAssignWithHttpInfo(productId = productId, categoryId = categoryId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.assign
     * Assign category to product
     * @param productId Defines category assign to the product, specified by product id
     * @param categoryId Defines category assign, specified by category id
     * @param storeId Store Id (optional)
     * @return ApiResponse<CartConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryAssignWithHttpInfo(productId: kotlin.String, categoryId: kotlin.String, storeId: kotlin.String?) : ApiResponse<CartConfigUpdate200Response?> {
        val localVariableConfig = categoryAssignRequestConfig(productId = productId, categoryId = categoryId, storeId = storeId)

        return request<Unit, CartConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryAssign
     *
     * @param productId Defines category assign to the product, specified by product id
     * @param categoryId Defines category assign, specified by category id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun categoryAssignRequestConfig(productId: kotlin.String, categoryId: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                put("category_id", listOf(categoryId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/category.assign.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.count
     * Count categories in store.
     * @param parentId Counts categories specified by parent id (optional)
     * @param storeId Counts category specified by store id (optional)
     * @param langId Counts category specified by language id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param productType A categorization for the product (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Counts categories that are searched specified by field (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @return CategoryCount200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryCount(parentId: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, avail: kotlin.Boolean? = true, productType: kotlin.String? = null, findValue: kotlin.String? = null, findWhere: kotlin.String? = null, reportRequestId: kotlin.String? = null, disableReportCache: kotlin.Boolean? = false) : CategoryCount200Response {
        val localVarResponse = categoryCountWithHttpInfo(parentId = parentId, storeId = storeId, langId = langId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, avail = avail, productType = productType, findValue = findValue, findWhere = findWhere, reportRequestId = reportRequestId, disableReportCache = disableReportCache)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryCount200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.count
     * Count categories in store.
     * @param parentId Counts categories specified by parent id (optional)
     * @param storeId Counts category specified by store id (optional)
     * @param langId Counts category specified by language id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param productType A categorization for the product (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Counts categories that are searched specified by field (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @return ApiResponse<CategoryCount200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryCountWithHttpInfo(parentId: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, avail: kotlin.Boolean?, productType: kotlin.String?, findValue: kotlin.String?, findWhere: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?) : ApiResponse<CategoryCount200Response?> {
        val localVariableConfig = categoryCountRequestConfig(parentId = parentId, storeId = storeId, langId = langId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, avail = avail, productType = productType, findValue = findValue, findWhere = findWhere, reportRequestId = reportRequestId, disableReportCache = disableReportCache)

        return request<Unit, CategoryCount200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryCount
     *
     * @param parentId Counts categories specified by parent id (optional)
     * @param storeId Counts category specified by store id (optional)
     * @param langId Counts category specified by language id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param productType A categorization for the product (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Counts categories that are searched specified by field (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @return RequestConfig
     */
    fun categoryCountRequestConfig(parentId: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, avail: kotlin.Boolean?, productType: kotlin.String?, findValue: kotlin.String?, findWhere: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (parentId != null) {
                    put("parent_id", listOf(parentId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
                if (productType != null) {
                    put("product_type", listOf(productType.toString()))
                }
                if (findValue != null) {
                    put("find_value", listOf(findValue.toString()))
                }
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (reportRequestId != null) {
                    put("report_request_id", listOf(reportRequestId.toString()))
                }
                if (disableReportCache != null) {
                    put("disable_report_cache", listOf(disableReportCache.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/category.count.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.delete
     * Delete category in store
     * @param id Defines category removal, specified by category id
     * @param storeId Store Id (optional)
     * @return CategoryDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryDelete(id: kotlin.String, storeId: kotlin.String? = null) : CategoryDelete200Response {
        val localVarResponse = categoryDeleteWithHttpInfo(id = id, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.delete
     * Delete category in store
     * @param id Defines category removal, specified by category id
     * @param storeId Store Id (optional)
     * @return ApiResponse<CategoryDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryDeleteWithHttpInfo(id: kotlin.String, storeId: kotlin.String?) : ApiResponse<CategoryDelete200Response?> {
        val localVariableConfig = categoryDeleteRequestConfig(id = id, storeId = storeId)

        return request<Unit, CategoryDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryDelete
     *
     * @param id Defines category removal, specified by category id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun categoryDeleteRequestConfig(id: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/category.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.find
     * Search category in store. \&quot;Laptop\&quot; is specified here by default.
     * @param findValue Entity search that is specified by some value
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional, default to "name")
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return CategoryFind200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryFind(findValue: kotlin.String, findWhere: kotlin.String? = "name", findParams: kotlin.String? = "whole_words", storeId: kotlin.String? = null, langId: kotlin.String? = null) : CategoryFind200Response {
        val localVarResponse = categoryFindWithHttpInfo(findValue = findValue, findWhere = findWhere, findParams = findParams, storeId = storeId, langId = langId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryFind200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.find
     * Search category in store. \&quot;Laptop\&quot; is specified here by default.
     * @param findValue Entity search that is specified by some value
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional, default to "name")
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return ApiResponse<CategoryFind200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryFindWithHttpInfo(findValue: kotlin.String, findWhere: kotlin.String?, findParams: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?) : ApiResponse<CategoryFind200Response?> {
        val localVariableConfig = categoryFindRequestConfig(findValue = findValue, findWhere = findWhere, findParams = findParams, storeId = storeId, langId = langId)

        return request<Unit, CategoryFind200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryFind
     *
     * @param findValue Entity search that is specified by some value
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional, default to "name")
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return RequestConfig
     */
    fun categoryFindRequestConfig(findValue: kotlin.String, findWhere: kotlin.String?, findParams: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("find_value", listOf(findValue.toString()))
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (findParams != null) {
                    put("find_params", listOf(findParams.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/category.find.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter type
     */
     enum class TypeCategoryImageAdd(val value: kotlin.String) {
         @Json(name = "base") base("base"),
         @Json(name = "thumbnail") thumbnail("thumbnail");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * category.image.add
     * Add image to category
     * @param categoryId Defines category id where the image should be added
     * @param imageName Defines image&#39;s name
     * @param url Defines URL of the image that has to be added
     * @param type Defines image&#39;s types that are specified by comma-separated list
     * @param label Defines alternative text that has to be attached to the picture (optional)
     * @param mime Mime type of image http://en.wikipedia.org/wiki/Internet_media_type. (optional)
     * @param position Defines image’s position in the list (optional, default to 0)
     * @param storeId Store Id (optional)
     * @return CategoryImageAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryImageAdd(categoryId: kotlin.String, imageName: kotlin.String, url: kotlin.String, type: TypeCategoryImageAdd, label: kotlin.String? = null, mime: kotlin.String? = null, position: kotlin.Int? = 0, storeId: kotlin.String? = null) : CategoryImageAdd200Response {
        val localVarResponse = categoryImageAddWithHttpInfo(categoryId = categoryId, imageName = imageName, url = url, type = type, label = label, mime = mime, position = position, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryImageAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.image.add
     * Add image to category
     * @param categoryId Defines category id where the image should be added
     * @param imageName Defines image&#39;s name
     * @param url Defines URL of the image that has to be added
     * @param type Defines image&#39;s types that are specified by comma-separated list
     * @param label Defines alternative text that has to be attached to the picture (optional)
     * @param mime Mime type of image http://en.wikipedia.org/wiki/Internet_media_type. (optional)
     * @param position Defines image’s position in the list (optional, default to 0)
     * @param storeId Store Id (optional)
     * @return ApiResponse<CategoryImageAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryImageAddWithHttpInfo(categoryId: kotlin.String, imageName: kotlin.String, url: kotlin.String, type: TypeCategoryImageAdd, label: kotlin.String?, mime: kotlin.String?, position: kotlin.Int?, storeId: kotlin.String?) : ApiResponse<CategoryImageAdd200Response?> {
        val localVariableConfig = categoryImageAddRequestConfig(categoryId = categoryId, imageName = imageName, url = url, type = type, label = label, mime = mime, position = position, storeId = storeId)

        return request<Unit, CategoryImageAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryImageAdd
     *
     * @param categoryId Defines category id where the image should be added
     * @param imageName Defines image&#39;s name
     * @param url Defines URL of the image that has to be added
     * @param type Defines image&#39;s types that are specified by comma-separated list
     * @param label Defines alternative text that has to be attached to the picture (optional)
     * @param mime Mime type of image http://en.wikipedia.org/wiki/Internet_media_type. (optional)
     * @param position Defines image’s position in the list (optional, default to 0)
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun categoryImageAddRequestConfig(categoryId: kotlin.String, imageName: kotlin.String, url: kotlin.String, type: TypeCategoryImageAdd, label: kotlin.String?, mime: kotlin.String?, position: kotlin.Int?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("category_id", listOf(categoryId.toString()))
                put("image_name", listOf(imageName.toString()))
                put("url", listOf(url.toString()))
                if (label != null) {
                    put("label", listOf(label.toString()))
                }
                if (mime != null) {
                    put("mime", listOf(mime.toString()))
                }
                put("type", listOf(type.value))
                if (position != null) {
                    put("position", listOf(position.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/category.image.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.image.delete
     * Delete image
     * @param categoryId Defines category id where the image should be deleted
     * @param imageId Define image id
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryImageDelete(categoryId: kotlin.String, imageId: kotlin.String, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = categoryImageDeleteWithHttpInfo(categoryId = categoryId, imageId = imageId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.image.delete
     * Delete image
     * @param categoryId Defines category id where the image should be deleted
     * @param imageId Define image id
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryImageDeleteWithHttpInfo(categoryId: kotlin.String, imageId: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = categoryImageDeleteRequestConfig(categoryId = categoryId, imageId = imageId, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryImageDelete
     *
     * @param categoryId Defines category id where the image should be deleted
     * @param imageId Define image id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun categoryImageDeleteRequestConfig(categoryId: kotlin.String, imageId: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("category_id", listOf(categoryId.toString()))
                put("image_id", listOf(imageId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/category.image.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.info
     * Get category info about category ID*** or specify other category ID.
     * @param id Retrieves category&#39;s info specified by category id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,parent_id,name,description")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves category info  specified by store id (optional)
     * @param langId Retrieves category info  specified by language id (optional)
     * @param schemaType The name of the requirements set for the provided schema. (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @return CategoryInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryInfo(id: kotlin.String, params: kotlin.String? = "id,parent_id,name,description", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, schemaType: kotlin.String? = null, reportRequestId: kotlin.String? = null, disableReportCache: kotlin.Boolean? = false) : CategoryInfo200Response {
        val localVarResponse = categoryInfoWithHttpInfo(id = id, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId, langId = langId, schemaType = schemaType, reportRequestId = reportRequestId, disableReportCache = disableReportCache)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.info
     * Get category info about category ID*** or specify other category ID.
     * @param id Retrieves category&#39;s info specified by category id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,parent_id,name,description")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves category info  specified by store id (optional)
     * @param langId Retrieves category info  specified by language id (optional)
     * @param schemaType The name of the requirements set for the provided schema. (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @return ApiResponse<CategoryInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryInfoWithHttpInfo(id: kotlin.String, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, schemaType: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?) : ApiResponse<CategoryInfo200Response?> {
        val localVariableConfig = categoryInfoRequestConfig(id = id, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId, langId = langId, schemaType = schemaType, reportRequestId = reportRequestId, disableReportCache = disableReportCache)

        return request<Unit, CategoryInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryInfo
     *
     * @param id Retrieves category&#39;s info specified by category id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,parent_id,name,description")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves category info  specified by store id (optional)
     * @param langId Retrieves category info  specified by language id (optional)
     * @param schemaType The name of the requirements set for the provided schema. (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @return RequestConfig
     */
    fun categoryInfoRequestConfig(id: kotlin.String, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, schemaType: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (schemaType != null) {
                    put("schema_type", listOf(schemaType.toString()))
                }
                if (reportRequestId != null) {
                    put("report_request_id", listOf(reportRequestId.toString()))
                }
                if (disableReportCache != null) {
                    put("disable_report_cache", listOf(disableReportCache.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/category.info.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.list
     * Get list of categories from store.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param parentId Retrieves categories specified by parent id (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,parent_id,name,description")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves categories specified by store id (optional)
     * @param langId Retrieves categorys specified by language id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param productType A categorization for the product (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Category search that is specified by field (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param disableCache Disable cache for current request (optional, default to false)
     * @return ModelResponseCategoryList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, parentId: kotlin.String? = null, params: kotlin.String? = "id,parent_id,name,description", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, avail: kotlin.Boolean? = true, productType: kotlin.String? = null, findValue: kotlin.String? = null, findWhere: kotlin.String? = null, reportRequestId: kotlin.String? = null, disableReportCache: kotlin.Boolean? = false, disableCache: kotlin.Boolean? = false) : ModelResponseCategoryList {
        val localVarResponse = categoryListWithHttpInfo(start = start, count = count, pageCursor = pageCursor, parentId = parentId, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId, langId = langId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, avail = avail, productType = productType, findValue = findValue, findWhere = findWhere, reportRequestId = reportRequestId, disableReportCache = disableReportCache, disableCache = disableCache)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCategoryList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.list
     * Get list of categories from store.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param parentId Retrieves categories specified by parent id (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,parent_id,name,description")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves categories specified by store id (optional)
     * @param langId Retrieves categorys specified by language id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param productType A categorization for the product (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Category search that is specified by field (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param disableCache Disable cache for current request (optional, default to false)
     * @return ApiResponse<ModelResponseCategoryList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, parentId: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, avail: kotlin.Boolean?, productType: kotlin.String?, findValue: kotlin.String?, findWhere: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, disableCache: kotlin.Boolean?) : ApiResponse<ModelResponseCategoryList?> {
        val localVariableConfig = categoryListRequestConfig(start = start, count = count, pageCursor = pageCursor, parentId = parentId, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId, langId = langId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, avail = avail, productType = productType, findValue = findValue, findWhere = findWhere, reportRequestId = reportRequestId, disableReportCache = disableReportCache, disableCache = disableCache)

        return request<Unit, ModelResponseCategoryList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param parentId Retrieves categories specified by parent id (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,parent_id,name,description")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves categories specified by store id (optional)
     * @param langId Retrieves categorys specified by language id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param productType A categorization for the product (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Category search that is specified by field (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param disableCache Disable cache for current request (optional, default to false)
     * @return RequestConfig
     */
    fun categoryListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, parentId: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, avail: kotlin.Boolean?, productType: kotlin.String?, findValue: kotlin.String?, findWhere: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, disableCache: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (parentId != null) {
                    put("parent_id", listOf(parentId.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
                if (productType != null) {
                    put("product_type", listOf(productType.toString()))
                }
                if (findValue != null) {
                    put("find_value", listOf(findValue.toString()))
                }
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (reportRequestId != null) {
                    put("report_request_id", listOf(reportRequestId.toString()))
                }
                if (disableReportCache != null) {
                    put("disable_report_cache", listOf(disableReportCache.toString()))
                }
                if (disableCache != null) {
                    put("disable_cache", listOf(disableCache.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/category.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.unassign
     * Unassign category to product
     * @param categoryId Defines category unassign, specified by category id
     * @param productId Defines category unassign to the product, specified by product id
     * @param storeId Store Id (optional)
     * @return CartConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryUnassign(categoryId: kotlin.String, productId: kotlin.String, storeId: kotlin.String? = null) : CartConfigUpdate200Response {
        val localVarResponse = categoryUnassignWithHttpInfo(categoryId = categoryId, productId = productId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.unassign
     * Unassign category to product
     * @param categoryId Defines category unassign, specified by category id
     * @param productId Defines category unassign to the product, specified by product id
     * @param storeId Store Id (optional)
     * @return ApiResponse<CartConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryUnassignWithHttpInfo(categoryId: kotlin.String, productId: kotlin.String, storeId: kotlin.String?) : ApiResponse<CartConfigUpdate200Response?> {
        val localVariableConfig = categoryUnassignRequestConfig(categoryId = categoryId, productId = productId, storeId = storeId)

        return request<Unit, CartConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryUnassign
     *
     * @param categoryId Defines category unassign, specified by category id
     * @param productId Defines category unassign to the product, specified by product id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun categoryUnassignRequestConfig(categoryId: kotlin.String, productId: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("category_id", listOf(categoryId.toString()))
                put("product_id", listOf(productId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/category.unassign.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * category.update
     * Update category in store
     * @param id Defines category update specified by category id
     * @param name Defines new category’s name (optional)
     * @param parentId Defines new parent category id (optional)
     * @param storesIds Update category in the stores that is specified by comma-separated stores&#39; id (optional)
     * @param avail Defines category&#39;s visibility status (optional)
     * @param sortOrder Sort number in the list (optional)
     * @param modifiedTime Entity&#39;s date modification (optional)
     * @param description Defines new category&#39;s description (optional)
     * @param shortDescription Defines short description (optional)
     * @param metaTitle Defines unique meta title for each entity (optional)
     * @param metaDescription Defines unique meta description of a entity (optional)
     * @param metaKeywords Defines unique meta keywords for each entity (optional)
     * @param seoUrl Defines unique category&#39;s URL for SEO (optional)
     * @param langId Language id (optional)
     * @param storeId Store Id (optional)
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun categoryUpdate(id: kotlin.String, name: kotlin.String? = null, parentId: kotlin.String? = null, storesIds: kotlin.String? = null, avail: kotlin.Boolean? = null, sortOrder: kotlin.Int? = null, modifiedTime: kotlin.String? = null, description: kotlin.String? = null, shortDescription: kotlin.String? = null, metaTitle: kotlin.String? = null, metaDescription: kotlin.String? = null, metaKeywords: kotlin.String? = null, seoUrl: kotlin.String? = null, langId: kotlin.String? = null, storeId: kotlin.String? = null) : AccountConfigUpdate200Response {
        val localVarResponse = categoryUpdateWithHttpInfo(id = id, name = name, parentId = parentId, storesIds = storesIds, avail = avail, sortOrder = sortOrder, modifiedTime = modifiedTime, description = description, shortDescription = shortDescription, metaTitle = metaTitle, metaDescription = metaDescription, metaKeywords = metaKeywords, seoUrl = seoUrl, langId = langId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * category.update
     * Update category in store
     * @param id Defines category update specified by category id
     * @param name Defines new category’s name (optional)
     * @param parentId Defines new parent category id (optional)
     * @param storesIds Update category in the stores that is specified by comma-separated stores&#39; id (optional)
     * @param avail Defines category&#39;s visibility status (optional)
     * @param sortOrder Sort number in the list (optional)
     * @param modifiedTime Entity&#39;s date modification (optional)
     * @param description Defines new category&#39;s description (optional)
     * @param shortDescription Defines short description (optional)
     * @param metaTitle Defines unique meta title for each entity (optional)
     * @param metaDescription Defines unique meta description of a entity (optional)
     * @param metaKeywords Defines unique meta keywords for each entity (optional)
     * @param seoUrl Defines unique category&#39;s URL for SEO (optional)
     * @param langId Language id (optional)
     * @param storeId Store Id (optional)
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun categoryUpdateWithHttpInfo(id: kotlin.String, name: kotlin.String?, parentId: kotlin.String?, storesIds: kotlin.String?, avail: kotlin.Boolean?, sortOrder: kotlin.Int?, modifiedTime: kotlin.String?, description: kotlin.String?, shortDescription: kotlin.String?, metaTitle: kotlin.String?, metaDescription: kotlin.String?, metaKeywords: kotlin.String?, seoUrl: kotlin.String?, langId: kotlin.String?, storeId: kotlin.String?) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = categoryUpdateRequestConfig(id = id, name = name, parentId = parentId, storesIds = storesIds, avail = avail, sortOrder = sortOrder, modifiedTime = modifiedTime, description = description, shortDescription = shortDescription, metaTitle = metaTitle, metaDescription = metaDescription, metaKeywords = metaKeywords, seoUrl = seoUrl, langId = langId, storeId = storeId)

        return request<Unit, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation categoryUpdate
     *
     * @param id Defines category update specified by category id
     * @param name Defines new category’s name (optional)
     * @param parentId Defines new parent category id (optional)
     * @param storesIds Update category in the stores that is specified by comma-separated stores&#39; id (optional)
     * @param avail Defines category&#39;s visibility status (optional)
     * @param sortOrder Sort number in the list (optional)
     * @param modifiedTime Entity&#39;s date modification (optional)
     * @param description Defines new category&#39;s description (optional)
     * @param shortDescription Defines short description (optional)
     * @param metaTitle Defines unique meta title for each entity (optional)
     * @param metaDescription Defines unique meta description of a entity (optional)
     * @param metaKeywords Defines unique meta keywords for each entity (optional)
     * @param seoUrl Defines unique category&#39;s URL for SEO (optional)
     * @param langId Language id (optional)
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun categoryUpdateRequestConfig(id: kotlin.String, name: kotlin.String?, parentId: kotlin.String?, storesIds: kotlin.String?, avail: kotlin.Boolean?, sortOrder: kotlin.Int?, modifiedTime: kotlin.String?, description: kotlin.String?, shortDescription: kotlin.String?, metaTitle: kotlin.String?, metaDescription: kotlin.String?, metaKeywords: kotlin.String?, seoUrl: kotlin.String?, langId: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (parentId != null) {
                    put("parent_id", listOf(parentId.toString()))
                }
                if (storesIds != null) {
                    put("stores_ids", listOf(storesIds.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
                if (sortOrder != null) {
                    put("sort_order", listOf(sortOrder.toString()))
                }
                if (modifiedTime != null) {
                    put("modified_time", listOf(modifiedTime.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (shortDescription != null) {
                    put("short_description", listOf(shortDescription.toString()))
                }
                if (metaTitle != null) {
                    put("meta_title", listOf(metaTitle.toString()))
                }
                if (metaDescription != null) {
                    put("meta_description", listOf(metaDescription.toString()))
                }
                if (metaKeywords != null) {
                    put("meta_keywords", listOf(metaKeywords.toString()))
                }
                if (seoUrl != null) {
                    put("seo_url", listOf(seoUrl.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/category.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
