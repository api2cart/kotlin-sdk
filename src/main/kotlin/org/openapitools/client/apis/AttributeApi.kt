/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AttributeAdd200Response
import org.openapitools.client.models.AttributeAssignGroup200Response
import org.openapitools.client.models.AttributeCount200Response
import org.openapitools.client.models.AttributeDelete200Response
import org.openapitools.client.models.AttributeInfo200Response
import org.openapitools.client.models.AttributeTypeList200Response
import org.openapitools.client.models.AttributeUnassignGroup200Response
import org.openapitools.client.models.AttributeUpdate200Response
import org.openapitools.client.models.AttributeValueDelete200Response
import org.openapitools.client.models.ModelResponseAttributeAttributesetList
import org.openapitools.client.models.ModelResponseAttributeGroupList
import org.openapitools.client.models.ModelResponseAttributeList

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class AttributeApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.api2cart.com/v1.1")
        }
    }

    /**
     * enum for parameter type
     */
     enum class TypeAttributeAdd(val value: kotlin.String) {
         @Json(name = "text") text("text"),
         @Json(name = "select") select("select"),
         @Json(name = "textarea") textarea("textarea"),
         @Json(name = "date") date("date"),
         @Json(name = "price") price("price"),
         @Json(name = "multiselect") multiselect("multiselect"),
         @Json(name = "boolean") boolean("boolean");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * attribute.add
     * Add new attribute
     * @param type Defines attribute&#39;s type
     * @param name Defines attributes&#39;s name
     * @param code Entity code (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param visible Set visibility status (optional, default to false)
     * @param required Defines if the option is required (optional, default to false)
     * @param position Attribute&#x60;s position (optional, default to 0)
     * @param attributeGroupId Filter by attribute_group_id (optional)
     * @param isGlobal Attribute saving scope (optional, default to "Store")
     * @param isSearchable Use attribute in Quick Search (optional, default to false)
     * @param isFilterable Use In Layered Navigation (optional, default to "No")
     * @param isComparable Comparable on Front-end (optional, default to false)
     * @param isHtmlAllowedOnFront Allow HTML Tags on Frontend (optional, default to false)
     * @param isFilterableInSearch Use In Search Results Layered Navigation (optional, default to false)
     * @param isConfigurable Use To Create Configurable Product (optional, default to false)
     * @param isVisibleInAdvancedSearch Use in Advanced Search (optional, default to false)
     * @param isUsedForPromoRules Use for Promo Rule Conditions (optional, default to false)
     * @param usedInProductListing Used in Product Listing (optional, default to false)
     * @param usedForSortBy Used for Sorting in Product Listing (optional, default to false)
     * @param applyTo Types of products which can have this attribute (optional, default to "all_types")
     * @return AttributeAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeAdd(type: TypeAttributeAdd, name: kotlin.String, code: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, visible: kotlin.Boolean? = false, required: kotlin.Boolean? = false, position: kotlin.Int? = 0, attributeGroupId: kotlin.String? = null, isGlobal: kotlin.String? = "Store", isSearchable: kotlin.Boolean? = false, isFilterable: kotlin.String? = "No", isComparable: kotlin.Boolean? = false, isHtmlAllowedOnFront: kotlin.Boolean? = false, isFilterableInSearch: kotlin.Boolean? = false, isConfigurable: kotlin.Boolean? = false, isVisibleInAdvancedSearch: kotlin.Boolean? = false, isUsedForPromoRules: kotlin.Boolean? = false, usedInProductListing: kotlin.Boolean? = false, usedForSortBy: kotlin.Boolean? = false, applyTo: kotlin.String? = "all_types") : AttributeAdd200Response {
        val localVarResponse = attributeAddWithHttpInfo(type = type, name = name, code = code, storeId = storeId, langId = langId, visible = visible, required = required, position = position, attributeGroupId = attributeGroupId, isGlobal = isGlobal, isSearchable = isSearchable, isFilterable = isFilterable, isComparable = isComparable, isHtmlAllowedOnFront = isHtmlAllowedOnFront, isFilterableInSearch = isFilterableInSearch, isConfigurable = isConfigurable, isVisibleInAdvancedSearch = isVisibleInAdvancedSearch, isUsedForPromoRules = isUsedForPromoRules, usedInProductListing = usedInProductListing, usedForSortBy = usedForSortBy, applyTo = applyTo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.add
     * Add new attribute
     * @param type Defines attribute&#39;s type
     * @param name Defines attributes&#39;s name
     * @param code Entity code (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param visible Set visibility status (optional, default to false)
     * @param required Defines if the option is required (optional, default to false)
     * @param position Attribute&#x60;s position (optional, default to 0)
     * @param attributeGroupId Filter by attribute_group_id (optional)
     * @param isGlobal Attribute saving scope (optional, default to "Store")
     * @param isSearchable Use attribute in Quick Search (optional, default to false)
     * @param isFilterable Use In Layered Navigation (optional, default to "No")
     * @param isComparable Comparable on Front-end (optional, default to false)
     * @param isHtmlAllowedOnFront Allow HTML Tags on Frontend (optional, default to false)
     * @param isFilterableInSearch Use In Search Results Layered Navigation (optional, default to false)
     * @param isConfigurable Use To Create Configurable Product (optional, default to false)
     * @param isVisibleInAdvancedSearch Use in Advanced Search (optional, default to false)
     * @param isUsedForPromoRules Use for Promo Rule Conditions (optional, default to false)
     * @param usedInProductListing Used in Product Listing (optional, default to false)
     * @param usedForSortBy Used for Sorting in Product Listing (optional, default to false)
     * @param applyTo Types of products which can have this attribute (optional, default to "all_types")
     * @return ApiResponse<AttributeAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeAddWithHttpInfo(type: TypeAttributeAdd, name: kotlin.String, code: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, visible: kotlin.Boolean?, required: kotlin.Boolean?, position: kotlin.Int?, attributeGroupId: kotlin.String?, isGlobal: kotlin.String?, isSearchable: kotlin.Boolean?, isFilterable: kotlin.String?, isComparable: kotlin.Boolean?, isHtmlAllowedOnFront: kotlin.Boolean?, isFilterableInSearch: kotlin.Boolean?, isConfigurable: kotlin.Boolean?, isVisibleInAdvancedSearch: kotlin.Boolean?, isUsedForPromoRules: kotlin.Boolean?, usedInProductListing: kotlin.Boolean?, usedForSortBy: kotlin.Boolean?, applyTo: kotlin.String?) : ApiResponse<AttributeAdd200Response?> {
        val localVariableConfig = attributeAddRequestConfig(type = type, name = name, code = code, storeId = storeId, langId = langId, visible = visible, required = required, position = position, attributeGroupId = attributeGroupId, isGlobal = isGlobal, isSearchable = isSearchable, isFilterable = isFilterable, isComparable = isComparable, isHtmlAllowedOnFront = isHtmlAllowedOnFront, isFilterableInSearch = isFilterableInSearch, isConfigurable = isConfigurable, isVisibleInAdvancedSearch = isVisibleInAdvancedSearch, isUsedForPromoRules = isUsedForPromoRules, usedInProductListing = usedInProductListing, usedForSortBy = usedForSortBy, applyTo = applyTo)

        return request<Unit, AttributeAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeAdd
     *
     * @param type Defines attribute&#39;s type
     * @param name Defines attributes&#39;s name
     * @param code Entity code (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param visible Set visibility status (optional, default to false)
     * @param required Defines if the option is required (optional, default to false)
     * @param position Attribute&#x60;s position (optional, default to 0)
     * @param attributeGroupId Filter by attribute_group_id (optional)
     * @param isGlobal Attribute saving scope (optional, default to "Store")
     * @param isSearchable Use attribute in Quick Search (optional, default to false)
     * @param isFilterable Use In Layered Navigation (optional, default to "No")
     * @param isComparable Comparable on Front-end (optional, default to false)
     * @param isHtmlAllowedOnFront Allow HTML Tags on Frontend (optional, default to false)
     * @param isFilterableInSearch Use In Search Results Layered Navigation (optional, default to false)
     * @param isConfigurable Use To Create Configurable Product (optional, default to false)
     * @param isVisibleInAdvancedSearch Use in Advanced Search (optional, default to false)
     * @param isUsedForPromoRules Use for Promo Rule Conditions (optional, default to false)
     * @param usedInProductListing Used in Product Listing (optional, default to false)
     * @param usedForSortBy Used for Sorting in Product Listing (optional, default to false)
     * @param applyTo Types of products which can have this attribute (optional, default to "all_types")
     * @return RequestConfig
     */
    fun attributeAddRequestConfig(type: TypeAttributeAdd, name: kotlin.String, code: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, visible: kotlin.Boolean?, required: kotlin.Boolean?, position: kotlin.Int?, attributeGroupId: kotlin.String?, isGlobal: kotlin.String?, isSearchable: kotlin.Boolean?, isFilterable: kotlin.String?, isComparable: kotlin.Boolean?, isHtmlAllowedOnFront: kotlin.Boolean?, isFilterableInSearch: kotlin.Boolean?, isConfigurable: kotlin.Boolean?, isVisibleInAdvancedSearch: kotlin.Boolean?, isUsedForPromoRules: kotlin.Boolean?, usedInProductListing: kotlin.Boolean?, usedForSortBy: kotlin.Boolean?, applyTo: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("type", listOf(type.value))
                put("name", listOf(name.toString()))
                if (code != null) {
                    put("code", listOf(code.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (visible != null) {
                    put("visible", listOf(visible.toString()))
                }
                if (required != null) {
                    put("required", listOf(required.toString()))
                }
                if (position != null) {
                    put("position", listOf(position.toString()))
                }
                if (attributeGroupId != null) {
                    put("attribute_group_id", listOf(attributeGroupId.toString()))
                }
                if (isGlobal != null) {
                    put("is_global", listOf(isGlobal.toString()))
                }
                if (isSearchable != null) {
                    put("is_searchable", listOf(isSearchable.toString()))
                }
                if (isFilterable != null) {
                    put("is_filterable", listOf(isFilterable.toString()))
                }
                if (isComparable != null) {
                    put("is_comparable", listOf(isComparable.toString()))
                }
                if (isHtmlAllowedOnFront != null) {
                    put("is_html_allowed_on_front", listOf(isHtmlAllowedOnFront.toString()))
                }
                if (isFilterableInSearch != null) {
                    put("is_filterable_in_search", listOf(isFilterableInSearch.toString()))
                }
                if (isConfigurable != null) {
                    put("is_configurable", listOf(isConfigurable.toString()))
                }
                if (isVisibleInAdvancedSearch != null) {
                    put("is_visible_in_advanced_search", listOf(isVisibleInAdvancedSearch.toString()))
                }
                if (isUsedForPromoRules != null) {
                    put("is_used_for_promo_rules", listOf(isUsedForPromoRules.toString()))
                }
                if (usedInProductListing != null) {
                    put("used_in_product_listing", listOf(usedInProductListing.toString()))
                }
                if (usedForSortBy != null) {
                    put("used_for_sort_by", listOf(usedForSortBy.toString()))
                }
                if (applyTo != null) {
                    put("apply_to", listOf(applyTo.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/attribute.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.assign.group
     * Assign attribute to the group
     * @param id Entity id
     * @param groupId Attribute group_id
     * @param attributeSetId Attribute set id (optional)
     * @return AttributeAssignGroup200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeAssignGroup(id: kotlin.String, groupId: kotlin.String, attributeSetId: kotlin.String? = null) : AttributeAssignGroup200Response {
        val localVarResponse = attributeAssignGroupWithHttpInfo(id = id, groupId = groupId, attributeSetId = attributeSetId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeAssignGroup200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.assign.group
     * Assign attribute to the group
     * @param id Entity id
     * @param groupId Attribute group_id
     * @param attributeSetId Attribute set id (optional)
     * @return ApiResponse<AttributeAssignGroup200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeAssignGroupWithHttpInfo(id: kotlin.String, groupId: kotlin.String, attributeSetId: kotlin.String?) : ApiResponse<AttributeAssignGroup200Response?> {
        val localVariableConfig = attributeAssignGroupRequestConfig(id = id, groupId = groupId, attributeSetId = attributeSetId)

        return request<Unit, AttributeAssignGroup200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeAssignGroup
     *
     * @param id Entity id
     * @param groupId Attribute group_id
     * @param attributeSetId Attribute set id (optional)
     * @return RequestConfig
     */
    fun attributeAssignGroupRequestConfig(id: kotlin.String, groupId: kotlin.String, attributeSetId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                put("group_id", listOf(groupId.toString()))
                if (attributeSetId != null) {
                    put("attribute_set_id", listOf(attributeSetId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/attribute.assign.group.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.assign.set
     * Assign attribute to the attribute set
     * @param id Entity id
     * @param attributeSetId Attribute set id
     * @param groupId Attribute group_id (optional)
     * @return AttributeAssignGroup200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeAssignSet(id: kotlin.String, attributeSetId: kotlin.String, groupId: kotlin.String? = null) : AttributeAssignGroup200Response {
        val localVarResponse = attributeAssignSetWithHttpInfo(id = id, attributeSetId = attributeSetId, groupId = groupId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeAssignGroup200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.assign.set
     * Assign attribute to the attribute set
     * @param id Entity id
     * @param attributeSetId Attribute set id
     * @param groupId Attribute group_id (optional)
     * @return ApiResponse<AttributeAssignGroup200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeAssignSetWithHttpInfo(id: kotlin.String, attributeSetId: kotlin.String, groupId: kotlin.String?) : ApiResponse<AttributeAssignGroup200Response?> {
        val localVariableConfig = attributeAssignSetRequestConfig(id = id, attributeSetId = attributeSetId, groupId = groupId)

        return request<Unit, AttributeAssignGroup200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeAssignSet
     *
     * @param id Entity id
     * @param attributeSetId Attribute set id
     * @param groupId Attribute group_id (optional)
     * @return RequestConfig
     */
    fun attributeAssignSetRequestConfig(id: kotlin.String, attributeSetId: kotlin.String, groupId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (groupId != null) {
                    put("group_id", listOf(groupId.toString()))
                }
                put("attribute_set_id", listOf(attributeSetId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/attribute.assign.set.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.attributeset.list
     * Get attribute_set list
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseAttributeAttributesetList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeAttributesetList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, responseFields: kotlin.String? = null, params: kotlin.String? = "id,name", exclude: kotlin.String? = null) : ModelResponseAttributeAttributesetList {
        val localVarResponse = attributeAttributesetListWithHttpInfo(start = start, count = count, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseAttributeAttributesetList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.attributeset.list
     * Get attribute_set list
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseAttributeAttributesetList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeAttributesetListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseAttributeAttributesetList?> {
        val localVariableConfig = attributeAttributesetListRequestConfig(start = start, count = count, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseAttributeAttributesetList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeAttributesetList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun attributeAttributesetListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/attribute.attributeset.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.count
     * Get attributes count
     * @param type Defines attribute&#39;s type (optional)
     * @param attributeSetId Filter items by attribute set id (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param visible Filter items by visibility status (optional)
     * @param required Defines if the option is required (optional)
     * @param system True if attribute is system (optional)
     * @return AttributeCount200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeCount(type: kotlin.String? = null, attributeSetId: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, visible: kotlin.Boolean? = null, required: kotlin.Boolean? = null, system: kotlin.Boolean? = null) : AttributeCount200Response {
        val localVarResponse = attributeCountWithHttpInfo(type = type, attributeSetId = attributeSetId, storeId = storeId, langId = langId, visible = visible, required = required, system = system)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeCount200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.count
     * Get attributes count
     * @param type Defines attribute&#39;s type (optional)
     * @param attributeSetId Filter items by attribute set id (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param visible Filter items by visibility status (optional)
     * @param required Defines if the option is required (optional)
     * @param system True if attribute is system (optional)
     * @return ApiResponse<AttributeCount200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeCountWithHttpInfo(type: kotlin.String?, attributeSetId: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, visible: kotlin.Boolean?, required: kotlin.Boolean?, system: kotlin.Boolean?) : ApiResponse<AttributeCount200Response?> {
        val localVariableConfig = attributeCountRequestConfig(type = type, attributeSetId = attributeSetId, storeId = storeId, langId = langId, visible = visible, required = required, system = system)

        return request<Unit, AttributeCount200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeCount
     *
     * @param type Defines attribute&#39;s type (optional)
     * @param attributeSetId Filter items by attribute set id (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param visible Filter items by visibility status (optional)
     * @param required Defines if the option is required (optional)
     * @param system True if attribute is system (optional)
     * @return RequestConfig
     */
    fun attributeCountRequestConfig(type: kotlin.String?, attributeSetId: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, visible: kotlin.Boolean?, required: kotlin.Boolean?, system: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (attributeSetId != null) {
                    put("attribute_set_id", listOf(attributeSetId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (visible != null) {
                    put("visible", listOf(visible.toString()))
                }
                if (required != null) {
                    put("required", listOf(required.toString()))
                }
                if (system != null) {
                    put("system", listOf(system.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/attribute.count.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.delete
     * Delete attribute from store
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeDelete(id: kotlin.String, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = attributeDeleteWithHttpInfo(id = id, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.delete
     * Delete attribute from store
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeDeleteWithHttpInfo(id: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = attributeDeleteRequestConfig(id = id, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeDelete
     *
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun attributeDeleteRequestConfig(id: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/attribute.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.group.list
     * Get attribute group list
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param attributeSetId Attribute set id (optional)
     * @param langId Language id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseAttributeGroupList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeGroupList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, attributeSetId: kotlin.String? = null, langId: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "id,name", exclude: kotlin.String? = null) : ModelResponseAttributeGroupList {
        val localVarResponse = attributeGroupListWithHttpInfo(start = start, count = count, attributeSetId = attributeSetId, langId = langId, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseAttributeGroupList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.group.list
     * Get attribute group list
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param attributeSetId Attribute set id (optional)
     * @param langId Language id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseAttributeGroupList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeGroupListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, attributeSetId: kotlin.String?, langId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseAttributeGroupList?> {
        val localVariableConfig = attributeGroupListRequestConfig(start = start, count = count, attributeSetId = attributeSetId, langId = langId, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseAttributeGroupList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeGroupList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param attributeSetId Attribute set id (optional)
     * @param langId Language id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun attributeGroupListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, attributeSetId: kotlin.String?, langId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (attributeSetId != null) {
                    put("attribute_set_id", listOf(attributeSetId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/attribute.group.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.info
     * Get information about a specific global attribute by its ID.
     * @param id Entity id
     * @param attributeSetId Attribute set id (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return AttributeInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeInfo(id: kotlin.String, attributeSetId: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "force_all", exclude: kotlin.String? = null) : AttributeInfo200Response {
        val localVarResponse = attributeInfoWithHttpInfo(id = id, attributeSetId = attributeSetId, storeId = storeId, langId = langId, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.info
     * Get information about a specific global attribute by its ID.
     * @param id Entity id
     * @param attributeSetId Attribute set id (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<AttributeInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeInfoWithHttpInfo(id: kotlin.String, attributeSetId: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<AttributeInfo200Response?> {
        val localVariableConfig = attributeInfoRequestConfig(id = id, attributeSetId = attributeSetId, storeId = storeId, langId = langId, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, AttributeInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeInfo
     *
     * @param id Entity id
     * @param attributeSetId Attribute set id (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun attributeInfoRequestConfig(id: kotlin.String, attributeSetId: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (attributeSetId != null) {
                    put("attribute_set_id", listOf(attributeSetId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/attribute.info.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.list
     * Get a list of global attributes.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param attributeIds Filter attributes by ids (optional)
     * @param attributeSetId Filter items by attribute set id (optional)
     * @param storeId Store Id (optional)
     * @param langId Retrieves attributes on specified language id (optional)
     * @param type Defines attribute&#39;s type (optional)
     * @param visible Filter items by visibility status (optional)
     * @param required Defines if the option is required (optional)
     * @param system True if attribute is system (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,code,type")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseAttributeList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, attributeIds: kotlin.String? = null, attributeSetId: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, type: kotlin.String? = null, visible: kotlin.Boolean? = null, required: kotlin.Boolean? = null, system: kotlin.Boolean? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "id,name,code,type", exclude: kotlin.String? = null) : ModelResponseAttributeList {
        val localVarResponse = attributeListWithHttpInfo(start = start, count = count, attributeIds = attributeIds, attributeSetId = attributeSetId, storeId = storeId, langId = langId, type = type, visible = visible, required = required, system = system, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseAttributeList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.list
     * Get a list of global attributes.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param attributeIds Filter attributes by ids (optional)
     * @param attributeSetId Filter items by attribute set id (optional)
     * @param storeId Store Id (optional)
     * @param langId Retrieves attributes on specified language id (optional)
     * @param type Defines attribute&#39;s type (optional)
     * @param visible Filter items by visibility status (optional)
     * @param required Defines if the option is required (optional)
     * @param system True if attribute is system (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,code,type")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseAttributeList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, attributeIds: kotlin.String?, attributeSetId: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, type: kotlin.String?, visible: kotlin.Boolean?, required: kotlin.Boolean?, system: kotlin.Boolean?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseAttributeList?> {
        val localVariableConfig = attributeListRequestConfig(start = start, count = count, attributeIds = attributeIds, attributeSetId = attributeSetId, storeId = storeId, langId = langId, type = type, visible = visible, required = required, system = system, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseAttributeList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param attributeIds Filter attributes by ids (optional)
     * @param attributeSetId Filter items by attribute set id (optional)
     * @param storeId Store Id (optional)
     * @param langId Retrieves attributes on specified language id (optional)
     * @param type Defines attribute&#39;s type (optional)
     * @param visible Filter items by visibility status (optional)
     * @param required Defines if the option is required (optional)
     * @param system True if attribute is system (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,code,type")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun attributeListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, attributeIds: kotlin.String?, attributeSetId: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, type: kotlin.String?, visible: kotlin.Boolean?, required: kotlin.Boolean?, system: kotlin.Boolean?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (attributeIds != null) {
                    put("attribute_ids", listOf(attributeIds.toString()))
                }
                if (attributeSetId != null) {
                    put("attribute_set_id", listOf(attributeSetId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (visible != null) {
                    put("visible", listOf(visible.toString()))
                }
                if (required != null) {
                    put("required", listOf(required.toString()))
                }
                if (system != null) {
                    put("system", listOf(system.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/attribute.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.type.list
     * Get list of supported attributes types
     * @return AttributeTypeList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeTypeList() : AttributeTypeList200Response {
        val localVarResponse = attributeTypeListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeTypeList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.type.list
     * Get list of supported attributes types
     * @return ApiResponse<AttributeTypeList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeTypeListWithHttpInfo() : ApiResponse<AttributeTypeList200Response?> {
        val localVariableConfig = attributeTypeListRequestConfig()

        return request<Unit, AttributeTypeList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeTypeList
     *
     * @return RequestConfig
     */
    fun attributeTypeListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/attribute.type.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.unassign.group
     * Unassign attribute from group
     * @param id Entity id
     * @param groupId Customer group_id
     * @return AttributeUnassignGroup200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeUnassignGroup(id: kotlin.String, groupId: kotlin.String) : AttributeUnassignGroup200Response {
        val localVarResponse = attributeUnassignGroupWithHttpInfo(id = id, groupId = groupId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeUnassignGroup200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.unassign.group
     * Unassign attribute from group
     * @param id Entity id
     * @param groupId Customer group_id
     * @return ApiResponse<AttributeUnassignGroup200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeUnassignGroupWithHttpInfo(id: kotlin.String, groupId: kotlin.String) : ApiResponse<AttributeUnassignGroup200Response?> {
        val localVariableConfig = attributeUnassignGroupRequestConfig(id = id, groupId = groupId)

        return request<Unit, AttributeUnassignGroup200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeUnassignGroup
     *
     * @param id Entity id
     * @param groupId Customer group_id
     * @return RequestConfig
     */
    fun attributeUnassignGroupRequestConfig(id: kotlin.String, groupId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                put("group_id", listOf(groupId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/attribute.unassign.group.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.unassign.set
     * Unassign attribute from attribute set
     * @param id Entity id
     * @param attributeSetId Attribute set id
     * @return AttributeUnassignGroup200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeUnassignSet(id: kotlin.String, attributeSetId: kotlin.String) : AttributeUnassignGroup200Response {
        val localVarResponse = attributeUnassignSetWithHttpInfo(id = id, attributeSetId = attributeSetId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeUnassignGroup200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.unassign.set
     * Unassign attribute from attribute set
     * @param id Entity id
     * @param attributeSetId Attribute set id
     * @return ApiResponse<AttributeUnassignGroup200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeUnassignSetWithHttpInfo(id: kotlin.String, attributeSetId: kotlin.String) : ApiResponse<AttributeUnassignGroup200Response?> {
        val localVariableConfig = attributeUnassignSetRequestConfig(id = id, attributeSetId = attributeSetId)

        return request<Unit, AttributeUnassignGroup200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeUnassignSet
     *
     * @param id Entity id
     * @param attributeSetId Attribute set id
     * @return RequestConfig
     */
    fun attributeUnassignSetRequestConfig(id: kotlin.String, attributeSetId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                put("attribute_set_id", listOf(attributeSetId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/attribute.unassign.set.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.update
     * Update attribute data
     * @param id Entity id
     * @param name Defines new attributes&#39;s name
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return AttributeUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeUpdate(id: kotlin.String, name: kotlin.String, storeId: kotlin.String? = null, langId: kotlin.String? = null) : AttributeUpdate200Response {
        val localVarResponse = attributeUpdateWithHttpInfo(id = id, name = name, storeId = storeId, langId = langId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.update
     * Update attribute data
     * @param id Entity id
     * @param name Defines new attributes&#39;s name
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return ApiResponse<AttributeUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeUpdateWithHttpInfo(id: kotlin.String, name: kotlin.String, storeId: kotlin.String?, langId: kotlin.String?) : ApiResponse<AttributeUpdate200Response?> {
        val localVariableConfig = attributeUpdateRequestConfig(id = id, name = name, storeId = storeId, langId = langId)

        return request<Unit, AttributeUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeUpdate
     *
     * @param id Entity id
     * @param name Defines new attributes&#39;s name
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return RequestConfig
     */
    fun attributeUpdateRequestConfig(id: kotlin.String, name: kotlin.String, storeId: kotlin.String?, langId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                put("name", listOf(name.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/attribute.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.value.add
     * Add new value to attribute.
     * @param attributeId Attribute Id
     * @param name Defines attribute value&#39;s name
     * @param code Entity code (optional)
     * @param description Defines attribute value&#39;s description (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return AttributeAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeValueAdd(attributeId: kotlin.String, name: kotlin.String, code: kotlin.String? = null, description: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null) : AttributeAdd200Response {
        val localVarResponse = attributeValueAddWithHttpInfo(attributeId = attributeId, name = name, code = code, description = description, storeId = storeId, langId = langId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.value.add
     * Add new value to attribute.
     * @param attributeId Attribute Id
     * @param name Defines attribute value&#39;s name
     * @param code Entity code (optional)
     * @param description Defines attribute value&#39;s description (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return ApiResponse<AttributeAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeValueAddWithHttpInfo(attributeId: kotlin.String, name: kotlin.String, code: kotlin.String?, description: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?) : ApiResponse<AttributeAdd200Response?> {
        val localVariableConfig = attributeValueAddRequestConfig(attributeId = attributeId, name = name, code = code, description = description, storeId = storeId, langId = langId)

        return request<Unit, AttributeAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeValueAdd
     *
     * @param attributeId Attribute Id
     * @param name Defines attribute value&#39;s name
     * @param code Entity code (optional)
     * @param description Defines attribute value&#39;s description (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return RequestConfig
     */
    fun attributeValueAddRequestConfig(attributeId: kotlin.String, name: kotlin.String, code: kotlin.String?, description: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("attribute_id", listOf(attributeId.toString()))
                put("name", listOf(name.toString()))
                if (code != null) {
                    put("code", listOf(code.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/attribute.value.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.value.delete
     * Delete attribute value.
     * @param id Entity id
     * @param attributeId Attribute Id
     * @param storeId Store Id (optional)
     * @return AttributeValueDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeValueDelete(id: kotlin.String, attributeId: kotlin.String, storeId: kotlin.String? = null) : AttributeValueDelete200Response {
        val localVarResponse = attributeValueDeleteWithHttpInfo(id = id, attributeId = attributeId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeValueDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.value.delete
     * Delete attribute value.
     * @param id Entity id
     * @param attributeId Attribute Id
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeValueDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeValueDeleteWithHttpInfo(id: kotlin.String, attributeId: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeValueDelete200Response?> {
        val localVariableConfig = attributeValueDeleteRequestConfig(id = id, attributeId = attributeId, storeId = storeId)

        return request<Unit, AttributeValueDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeValueDelete
     *
     * @param id Entity id
     * @param attributeId Attribute Id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun attributeValueDeleteRequestConfig(id: kotlin.String, attributeId: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                put("attribute_id", listOf(attributeId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/attribute.value.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * attribute.value.update
     * Update attribute value.
     * @param id Defines attribute value&#39;s id
     * @param attributeId Attribute Id
     * @param name Defines attribute value&#39;s name (optional)
     * @param description Defines new attribute value&#39;s description (optional)
     * @param code Entity code (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return AttributeUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attributeValueUpdate(id: kotlin.String, attributeId: kotlin.String, name: kotlin.String? = null, description: kotlin.String? = null, code: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null) : AttributeUpdate200Response {
        val localVarResponse = attributeValueUpdateWithHttpInfo(id = id, attributeId = attributeId, name = name, description = description, code = code, storeId = storeId, langId = langId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * attribute.value.update
     * Update attribute value.
     * @param id Defines attribute value&#39;s id
     * @param attributeId Attribute Id
     * @param name Defines attribute value&#39;s name (optional)
     * @param description Defines new attribute value&#39;s description (optional)
     * @param code Entity code (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return ApiResponse<AttributeUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attributeValueUpdateWithHttpInfo(id: kotlin.String, attributeId: kotlin.String, name: kotlin.String?, description: kotlin.String?, code: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?) : ApiResponse<AttributeUpdate200Response?> {
        val localVariableConfig = attributeValueUpdateRequestConfig(id = id, attributeId = attributeId, name = name, description = description, code = code, storeId = storeId, langId = langId)

        return request<Unit, AttributeUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attributeValueUpdate
     *
     * @param id Defines attribute value&#39;s id
     * @param attributeId Attribute Id
     * @param name Defines attribute value&#39;s name (optional)
     * @param description Defines new attribute value&#39;s description (optional)
     * @param code Entity code (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return RequestConfig
     */
    fun attributeValueUpdateRequestConfig(id: kotlin.String, attributeId: kotlin.String, name: kotlin.String?, description: kotlin.String?, code: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                put("attribute_id", listOf(attributeId.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (code != null) {
                    put("code", listOf(code.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/attribute.value.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
