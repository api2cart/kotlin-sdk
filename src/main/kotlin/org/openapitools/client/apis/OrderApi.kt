/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountConfigUpdate200Response
import org.openapitools.client.models.AttributeValueDelete200Response
import org.openapitools.client.models.CategoryAddBatch200Response
import org.openapitools.client.models.ModelResponseOrderAbandonedList
import org.openapitools.client.models.ModelResponseOrderList
import org.openapitools.client.models.ModelResponseOrderPreestimateShippingList
import org.openapitools.client.models.ModelResponseOrderShipmentList
import org.openapitools.client.models.ModelResponseOrderStatusList
import org.openapitools.client.models.ModelResponseOrderTransactionList
import org.openapitools.client.models.OrderAdd
import org.openapitools.client.models.OrderAdd200Response
import org.openapitools.client.models.OrderCalculate
import org.openapitools.client.models.OrderCalculate200Response
import org.openapitools.client.models.OrderCount200Response
import org.openapitools.client.models.OrderFinancialStatusList200Response
import org.openapitools.client.models.OrderFulfillmentStatusList200Response
import org.openapitools.client.models.OrderInfo200Response
import org.openapitools.client.models.OrderPreestimateShippingList
import org.openapitools.client.models.OrderRefundAdd
import org.openapitools.client.models.OrderRefundAdd200Response
import org.openapitools.client.models.OrderReturnAdd
import org.openapitools.client.models.OrderReturnAdd200Response
import org.openapitools.client.models.OrderReturnUpdate
import org.openapitools.client.models.OrderShipmentAdd
import org.openapitools.client.models.OrderShipmentAdd200Response
import org.openapitools.client.models.OrderShipmentAddBatch
import org.openapitools.client.models.OrderShipmentDelete200Response
import org.openapitools.client.models.OrderShipmentInfo200Response
import org.openapitools.client.models.OrderShipmentTrackingAdd
import org.openapitools.client.models.OrderShipmentTrackingAdd200Response
import org.openapitools.client.models.OrderShipmentUpdate

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class OrderApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.api2cart.local.com/v1.1")
        }
    }

    /**
     * order.abandoned.list
     * Get list of orders that were left by customers before completing the order.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param customerId Retrieves orders specified by customer id (optional)
     * @param customerEmail Retrieves orders specified by customer email (optional)
     * @param storeId Store Id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param skipEmptyEmail Filter empty emails (optional, default to false)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "customer,totals,items")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseOrderAbandonedList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderAbandonedList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, customerId: kotlin.String? = null, customerEmail: kotlin.String? = null, storeId: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, skipEmptyEmail: kotlin.Boolean? = false, responseFields: kotlin.String? = null, params: kotlin.String? = "customer,totals,items", exclude: kotlin.String? = null) : ModelResponseOrderAbandonedList {
        val localVarResponse = orderAbandonedListWithHttpInfo(start = start, count = count, pageCursor = pageCursor, customerId = customerId, customerEmail = customerEmail, storeId = storeId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, skipEmptyEmail = skipEmptyEmail, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseOrderAbandonedList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.abandoned.list
     * Get list of orders that were left by customers before completing the order.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param customerId Retrieves orders specified by customer id (optional)
     * @param customerEmail Retrieves orders specified by customer email (optional)
     * @param storeId Store Id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param skipEmptyEmail Filter empty emails (optional, default to false)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "customer,totals,items")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseOrderAbandonedList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderAbandonedListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, customerId: kotlin.String?, customerEmail: kotlin.String?, storeId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, skipEmptyEmail: kotlin.Boolean?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseOrderAbandonedList?> {
        val localVariableConfig = orderAbandonedListRequestConfig(start = start, count = count, pageCursor = pageCursor, customerId = customerId, customerEmail = customerEmail, storeId = storeId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, skipEmptyEmail = skipEmptyEmail, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseOrderAbandonedList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderAbandonedList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param customerId Retrieves orders specified by customer id (optional)
     * @param customerEmail Retrieves orders specified by customer email (optional)
     * @param storeId Store Id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param skipEmptyEmail Filter empty emails (optional, default to false)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "customer,totals,items")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun orderAbandonedListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, customerId: kotlin.String?, customerEmail: kotlin.String?, storeId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, skipEmptyEmail: kotlin.Boolean?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (customerId != null) {
                    put("customer_id", listOf(customerId.toString()))
                }
                if (customerEmail != null) {
                    put("customer_email", listOf(customerEmail.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (skipEmptyEmail != null) {
                    put("skip_empty_email", listOf(skipEmptyEmail.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.abandoned.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.add
     * Add a new order to the cart.
     * @param orderAdd 
     * @return OrderAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderAdd(orderAdd: OrderAdd) : OrderAdd200Response {
        val localVarResponse = orderAddWithHttpInfo(orderAdd = orderAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.add
     * Add a new order to the cart.
     * @param orderAdd 
     * @return ApiResponse<OrderAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderAddWithHttpInfo(orderAdd: OrderAdd) : ApiResponse<OrderAdd200Response?> {
        val localVariableConfig = orderAddRequestConfig(orderAdd = orderAdd)

        return request<OrderAdd, OrderAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderAdd
     *
     * @param orderAdd 
     * @return RequestConfig
     */
    fun orderAddRequestConfig(orderAdd: OrderAdd) : RequestConfig<OrderAdd> {
        val localVariableBody = orderAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.calculate
     * &lt;p&gt;Calculates the total cost of an order for a given customer and a set of products, as well as the available shipping methods based on the specified address. The calculation takes into account store product prices, discounts, taxes, shipping costs, and other store settings. The result includes a detailed breakdown of the final order cost by its components.&lt;/p&gt; &lt;p&gt;Note that the final totals, taxes, and other amounts must include the corresponding values for the selected shipping method.&lt;/p&gt;&lt;p&gt;The result of this method can be used when creating an order using the &lt;strong&gt;order.add&lt;/strong&gt; method.&lt;/p&gt;
     * @param orderCalculate 
     * @return OrderCalculate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderCalculate(orderCalculate: OrderCalculate) : OrderCalculate200Response {
        val localVarResponse = orderCalculateWithHttpInfo(orderCalculate = orderCalculate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderCalculate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.calculate
     * &lt;p&gt;Calculates the total cost of an order for a given customer and a set of products, as well as the available shipping methods based on the specified address. The calculation takes into account store product prices, discounts, taxes, shipping costs, and other store settings. The result includes a detailed breakdown of the final order cost by its components.&lt;/p&gt; &lt;p&gt;Note that the final totals, taxes, and other amounts must include the corresponding values for the selected shipping method.&lt;/p&gt;&lt;p&gt;The result of this method can be used when creating an order using the &lt;strong&gt;order.add&lt;/strong&gt; method.&lt;/p&gt;
     * @param orderCalculate 
     * @return ApiResponse<OrderCalculate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderCalculateWithHttpInfo(orderCalculate: OrderCalculate) : ApiResponse<OrderCalculate200Response?> {
        val localVariableConfig = orderCalculateRequestConfig(orderCalculate = orderCalculate)

        return request<OrderCalculate, OrderCalculate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderCalculate
     *
     * @param orderCalculate 
     * @return RequestConfig
     */
    fun orderCalculateRequestConfig(orderCalculate: OrderCalculate) : RequestConfig<OrderCalculate> {
        val localVariableBody = orderCalculate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order.calculate.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.count
     * Count orders in store
     * @param orderIds Counts orders specified by order ids (optional)
     * @param ids Counts orders specified by ids (optional)
     * @param customerId Counts orders quantity specified by customer id (optional)
     * @param storeId Counts orders quantity specified by store id (optional)
     * @param customerEmail Counts orders quantity specified by customer email (optional)
     * @param orderStatus Counts orders quantity specified by order status (optional)
     * @param orderStatusIds Retrieves orders specified by order statuses (optional)
     * @param ebayOrderStatus Counts orders quantity specified by order status (optional)
     * @param financialStatus Counts orders quantity specified by financial status (optional)
     * @param financialStatusIds Retrieves orders count specified by financial status ids (optional)
     * @param fulfillmentChannel Retrieves order with a fulfillment channel (optional)
     * @param fulfillmentStatus Create order with fulfillment status (optional)
     * @param shippingMethod Retrieve entities according to shipping method (optional)
     * @param deliveryMethod Retrieves order with delivery method (optional)
     * @param tags Order tags (optional)
     * @param shipNodeType Retrieves order with ship node type (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @return OrderCount200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderCount(orderIds: kotlin.String? = null, ids: kotlin.String? = null, customerId: kotlin.String? = null, storeId: kotlin.String? = null, customerEmail: kotlin.String? = null, orderStatus: kotlin.String? = null, orderStatusIds: kotlin.collections.List<kotlin.String>? = null, ebayOrderStatus: kotlin.String? = null, financialStatus: kotlin.String? = null, financialStatusIds: kotlin.collections.List<kotlin.String>? = null, fulfillmentChannel: kotlin.String? = null, fulfillmentStatus: kotlin.String? = null, shippingMethod: kotlin.String? = null, deliveryMethod: kotlin.String? = null, tags: kotlin.String? = null, shipNodeType: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null) : OrderCount200Response {
        val localVarResponse = orderCountWithHttpInfo(orderIds = orderIds, ids = ids, customerId = customerId, storeId = storeId, customerEmail = customerEmail, orderStatus = orderStatus, orderStatusIds = orderStatusIds, ebayOrderStatus = ebayOrderStatus, financialStatus = financialStatus, financialStatusIds = financialStatusIds, fulfillmentChannel = fulfillmentChannel, fulfillmentStatus = fulfillmentStatus, shippingMethod = shippingMethod, deliveryMethod = deliveryMethod, tags = tags, shipNodeType = shipNodeType, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderCount200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.count
     * Count orders in store
     * @param orderIds Counts orders specified by order ids (optional)
     * @param ids Counts orders specified by ids (optional)
     * @param customerId Counts orders quantity specified by customer id (optional)
     * @param storeId Counts orders quantity specified by store id (optional)
     * @param customerEmail Counts orders quantity specified by customer email (optional)
     * @param orderStatus Counts orders quantity specified by order status (optional)
     * @param orderStatusIds Retrieves orders specified by order statuses (optional)
     * @param ebayOrderStatus Counts orders quantity specified by order status (optional)
     * @param financialStatus Counts orders quantity specified by financial status (optional)
     * @param financialStatusIds Retrieves orders count specified by financial status ids (optional)
     * @param fulfillmentChannel Retrieves order with a fulfillment channel (optional)
     * @param fulfillmentStatus Create order with fulfillment status (optional)
     * @param shippingMethod Retrieve entities according to shipping method (optional)
     * @param deliveryMethod Retrieves order with delivery method (optional)
     * @param tags Order tags (optional)
     * @param shipNodeType Retrieves order with ship node type (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @return ApiResponse<OrderCount200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderCountWithHttpInfo(orderIds: kotlin.String?, ids: kotlin.String?, customerId: kotlin.String?, storeId: kotlin.String?, customerEmail: kotlin.String?, orderStatus: kotlin.String?, orderStatusIds: kotlin.collections.List<kotlin.String>?, ebayOrderStatus: kotlin.String?, financialStatus: kotlin.String?, financialStatusIds: kotlin.collections.List<kotlin.String>?, fulfillmentChannel: kotlin.String?, fulfillmentStatus: kotlin.String?, shippingMethod: kotlin.String?, deliveryMethod: kotlin.String?, tags: kotlin.String?, shipNodeType: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?) : ApiResponse<OrderCount200Response?> {
        val localVariableConfig = orderCountRequestConfig(orderIds = orderIds, ids = ids, customerId = customerId, storeId = storeId, customerEmail = customerEmail, orderStatus = orderStatus, orderStatusIds = orderStatusIds, ebayOrderStatus = ebayOrderStatus, financialStatus = financialStatus, financialStatusIds = financialStatusIds, fulfillmentChannel = fulfillmentChannel, fulfillmentStatus = fulfillmentStatus, shippingMethod = shippingMethod, deliveryMethod = deliveryMethod, tags = tags, shipNodeType = shipNodeType, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo)

        return request<Unit, OrderCount200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderCount
     *
     * @param orderIds Counts orders specified by order ids (optional)
     * @param ids Counts orders specified by ids (optional)
     * @param customerId Counts orders quantity specified by customer id (optional)
     * @param storeId Counts orders quantity specified by store id (optional)
     * @param customerEmail Counts orders quantity specified by customer email (optional)
     * @param orderStatus Counts orders quantity specified by order status (optional)
     * @param orderStatusIds Retrieves orders specified by order statuses (optional)
     * @param ebayOrderStatus Counts orders quantity specified by order status (optional)
     * @param financialStatus Counts orders quantity specified by financial status (optional)
     * @param financialStatusIds Retrieves orders count specified by financial status ids (optional)
     * @param fulfillmentChannel Retrieves order with a fulfillment channel (optional)
     * @param fulfillmentStatus Create order with fulfillment status (optional)
     * @param shippingMethod Retrieve entities according to shipping method (optional)
     * @param deliveryMethod Retrieves order with delivery method (optional)
     * @param tags Order tags (optional)
     * @param shipNodeType Retrieves order with ship node type (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @return RequestConfig
     */
    fun orderCountRequestConfig(orderIds: kotlin.String?, ids: kotlin.String?, customerId: kotlin.String?, storeId: kotlin.String?, customerEmail: kotlin.String?, orderStatus: kotlin.String?, orderStatusIds: kotlin.collections.List<kotlin.String>?, ebayOrderStatus: kotlin.String?, financialStatus: kotlin.String?, financialStatusIds: kotlin.collections.List<kotlin.String>?, fulfillmentChannel: kotlin.String?, fulfillmentStatus: kotlin.String?, shippingMethod: kotlin.String?, deliveryMethod: kotlin.String?, tags: kotlin.String?, shipNodeType: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (orderIds != null) {
                    put("order_ids", listOf(orderIds.toString()))
                }
                if (ids != null) {
                    put("ids", listOf(ids.toString()))
                }
                if (customerId != null) {
                    put("customer_id", listOf(customerId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (customerEmail != null) {
                    put("customer_email", listOf(customerEmail.toString()))
                }
                if (orderStatus != null) {
                    put("order_status", listOf(orderStatus.toString()))
                }
                if (orderStatusIds != null) {
                    put("order_status_ids", toMultiValue(orderStatusIds.toList(), "multi"))
                }
                if (ebayOrderStatus != null) {
                    put("ebay_order_status", listOf(ebayOrderStatus.toString()))
                }
                if (financialStatus != null) {
                    put("financial_status", listOf(financialStatus.toString()))
                }
                if (financialStatusIds != null) {
                    put("financial_status_ids", toMultiValue(financialStatusIds.toList(), "multi"))
                }
                if (fulfillmentChannel != null) {
                    put("fulfillment_channel", listOf(fulfillmentChannel.toString()))
                }
                if (fulfillmentStatus != null) {
                    put("fulfillment_status", listOf(fulfillmentStatus.toString()))
                }
                if (shippingMethod != null) {
                    put("shipping_method", listOf(shippingMethod.toString()))
                }
                if (deliveryMethod != null) {
                    put("delivery_method", listOf(deliveryMethod.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (shipNodeType != null) {
                    put("ship_node_type", listOf(shipNodeType.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.count.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.financial_status.list
     * Retrieve list of financial statuses
     * @return OrderFinancialStatusList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderFinancialStatusList() : OrderFinancialStatusList200Response {
        val localVarResponse = orderFinancialStatusListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderFinancialStatusList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.financial_status.list
     * Retrieve list of financial statuses
     * @return ApiResponse<OrderFinancialStatusList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderFinancialStatusListWithHttpInfo() : ApiResponse<OrderFinancialStatusList200Response?> {
        val localVariableConfig = orderFinancialStatusListRequestConfig()

        return request<Unit, OrderFinancialStatusList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderFinancialStatusList
     *
     * @return RequestConfig
     */
    fun orderFinancialStatusListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.financial_status.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.fulfillment_status.list
     * Retrieve list of fulfillment statuses
     * @param action Available statuses for the specified action. (optional)
     * @return OrderFulfillmentStatusList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderFulfillmentStatusList(action: kotlin.String? = null) : OrderFulfillmentStatusList200Response {
        val localVarResponse = orderFulfillmentStatusListWithHttpInfo(action = action)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderFulfillmentStatusList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.fulfillment_status.list
     * Retrieve list of fulfillment statuses
     * @param action Available statuses for the specified action. (optional)
     * @return ApiResponse<OrderFulfillmentStatusList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderFulfillmentStatusListWithHttpInfo(action: kotlin.String?) : ApiResponse<OrderFulfillmentStatusList200Response?> {
        val localVariableConfig = orderFulfillmentStatusListRequestConfig(action = action)

        return request<Unit, OrderFulfillmentStatusList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderFulfillmentStatusList
     *
     * @param action Available statuses for the specified action. (optional)
     * @return RequestConfig
     */
    fun orderFulfillmentStatusListRequestConfig(action: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (action != null) {
                    put("action", listOf(action.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.fulfillment_status.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.info
     * Info about a specific order by ID
     * @param id Retrieves order info specified by id (optional)
     * @param orderId Retrieves order’s info specified by order id (optional)
     * @param storeId Defines store id where the order should be found (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "order_id,customer,totals,address,items,bundles,status")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param enableCache If the value is &#39;true&#39; and order exist in our cache, we will return order.info response from cache (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param roundingPrecision &lt;p&gt;Specifies the rounding precision for fractional numeric values (such as prices, taxes, and weights).&lt;/p&gt; &lt;p&gt;Supported values range from &lt;b&gt;1&lt;/b&gt; to &lt;b&gt;6&lt;/b&gt;.&lt;/p&gt; &lt;p&gt;The default rounding precision may vary depending on the platform. You can retrieve the default value using the &lt;strong&gt;cart.info&lt;/strong&gt; method in the &lt;code&gt;default_rounding_precision&lt;/code&gt; field. &lt;/p&gt;&lt;p&gt;Values are rounded to the nearest number at the specified precision. Fractions of .5 or higher are rounded up, while fractions lower than .5 are rounded down.&lt;/p&gt; (optional)
     * @return OrderInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderInfo(id: kotlin.String? = null, orderId: kotlin.String? = null, storeId: kotlin.String? = null, params: kotlin.String? = "order_id,customer,totals,address,items,bundles,status", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, enableCache: kotlin.Boolean? = false, useLatestApiVersion: kotlin.Boolean? = false, roundingPrecision: kotlin.Int? = null) : OrderInfo200Response {
        val localVarResponse = orderInfoWithHttpInfo(id = id, orderId = orderId, storeId = storeId, params = params, responseFields = responseFields, exclude = exclude, enableCache = enableCache, useLatestApiVersion = useLatestApiVersion, roundingPrecision = roundingPrecision)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.info
     * Info about a specific order by ID
     * @param id Retrieves order info specified by id (optional)
     * @param orderId Retrieves order’s info specified by order id (optional)
     * @param storeId Defines store id where the order should be found (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "order_id,customer,totals,address,items,bundles,status")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param enableCache If the value is &#39;true&#39; and order exist in our cache, we will return order.info response from cache (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param roundingPrecision &lt;p&gt;Specifies the rounding precision for fractional numeric values (such as prices, taxes, and weights).&lt;/p&gt; &lt;p&gt;Supported values range from &lt;b&gt;1&lt;/b&gt; to &lt;b&gt;6&lt;/b&gt;.&lt;/p&gt; &lt;p&gt;The default rounding precision may vary depending on the platform. You can retrieve the default value using the &lt;strong&gt;cart.info&lt;/strong&gt; method in the &lt;code&gt;default_rounding_precision&lt;/code&gt; field. &lt;/p&gt;&lt;p&gt;Values are rounded to the nearest number at the specified precision. Fractions of .5 or higher are rounded up, while fractions lower than .5 are rounded down.&lt;/p&gt; (optional)
     * @return ApiResponse<OrderInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderInfoWithHttpInfo(id: kotlin.String?, orderId: kotlin.String?, storeId: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, enableCache: kotlin.Boolean?, useLatestApiVersion: kotlin.Boolean?, roundingPrecision: kotlin.Int?) : ApiResponse<OrderInfo200Response?> {
        val localVariableConfig = orderInfoRequestConfig(id = id, orderId = orderId, storeId = storeId, params = params, responseFields = responseFields, exclude = exclude, enableCache = enableCache, useLatestApiVersion = useLatestApiVersion, roundingPrecision = roundingPrecision)

        return request<Unit, OrderInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderInfo
     *
     * @param id Retrieves order info specified by id (optional)
     * @param orderId Retrieves order’s info specified by order id (optional)
     * @param storeId Defines store id where the order should be found (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "order_id,customer,totals,address,items,bundles,status")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param enableCache If the value is &#39;true&#39; and order exist in our cache, we will return order.info response from cache (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param roundingPrecision &lt;p&gt;Specifies the rounding precision for fractional numeric values (such as prices, taxes, and weights).&lt;/p&gt; &lt;p&gt;Supported values range from &lt;b&gt;1&lt;/b&gt; to &lt;b&gt;6&lt;/b&gt;.&lt;/p&gt; &lt;p&gt;The default rounding precision may vary depending on the platform. You can retrieve the default value using the &lt;strong&gt;cart.info&lt;/strong&gt; method in the &lt;code&gt;default_rounding_precision&lt;/code&gt; field. &lt;/p&gt;&lt;p&gt;Values are rounded to the nearest number at the specified precision. Fractions of .5 or higher are rounded up, while fractions lower than .5 are rounded down.&lt;/p&gt; (optional)
     * @return RequestConfig
     */
    fun orderInfoRequestConfig(id: kotlin.String?, orderId: kotlin.String?, storeId: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, enableCache: kotlin.Boolean?, useLatestApiVersion: kotlin.Boolean?, roundingPrecision: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (orderId != null) {
                    put("order_id", listOf(orderId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (enableCache != null) {
                    put("enable_cache", listOf(enableCache.toString()))
                }
                if (useLatestApiVersion != null) {
                    put("use_latest_api_version", listOf(useLatestApiVersion.toString()))
                }
                if (roundingPrecision != null) {
                    put("rounding_precision", listOf(roundingPrecision.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.info.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.list
     * Get list of orders from store.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve orders via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param ids Retrieves orders specified by ids (optional)
     * @param orderIds Retrieves orders specified by order ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @param storeId Store Id (optional)
     * @param customerId Retrieves orders specified by customer id (optional)
     * @param customerEmail Retrieves orders specified by customer email (optional)
     * @param basketId Retrieves order’s info specified by basket id. (optional)
     * @param currencyId Currency Id (optional)
     * @param phone Filter orders by customer&#39;s phone number (optional)
     * @param orderStatus Retrieves orders specified by order status (optional)
     * @param orderStatusIds Retrieves orders specified by order statuses (optional)
     * @param ebayOrderStatus Retrieves orders specified by order status (optional)
     * @param financialStatus Retrieves orders specified by financial status (optional)
     * @param financialStatusIds Retrieves orders specified by financial status ids (optional)
     * @param fulfillmentStatus Create order with fulfillment status (optional)
     * @param returnStatus Retrieves orders specified by return status (optional)
     * @param fulfillmentChannel Retrieves order with a fulfillment channel (optional)
     * @param shippingMethod Retrieve entities according to shipping method (optional)
     * @param skipOrderIds Skipped orders by ids (optional)
     * @param isDeleted Filter deleted orders (optional)
     * @param shippingCountryIso3 Retrieve entities according to shipping country (optional)
     * @param deliveryMethod Retrieves order with delivery method (optional)
     * @param shipNodeType Retrieves order with ship node type (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param tags Order tags (optional)
     * @param sortBy Set field to sort by (optional, default to "order_id")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "order_id,customer,totals,address,items,bundles,status")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param enableCache If the value is &#39;true&#39;, we will cache orders for a 15 minutes in order to increase speed and reduce requests throttling for some methods and shoping platforms (for example order.shipment.add) (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param roundingPrecision &lt;p&gt;Specifies the rounding precision for fractional numeric values (such as prices, taxes, and weights).&lt;/p&gt; &lt;p&gt;Supported values range from &lt;b&gt;1&lt;/b&gt; to &lt;b&gt;6&lt;/b&gt;.&lt;/p&gt; &lt;p&gt;The default rounding precision may vary depending on the platform. You can retrieve the default value using the &lt;strong&gt;cart.info&lt;/strong&gt; method in the &lt;code&gt;default_rounding_precision&lt;/code&gt; field. &lt;/p&gt;&lt;p&gt;Values are rounded to the nearest number at the specified precision. Fractions of .5 or higher are rounded up, while fractions lower than .5 are rounded down.&lt;/p&gt; (optional)
     * @return ModelResponseOrderList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, ids: kotlin.String? = null, orderIds: kotlin.String? = null, sinceId: kotlin.String? = null, storeId: kotlin.String? = null, customerId: kotlin.String? = null, customerEmail: kotlin.String? = null, basketId: kotlin.String? = null, currencyId: kotlin.String? = null, phone: kotlin.String? = null, orderStatus: kotlin.String? = null, orderStatusIds: kotlin.collections.List<kotlin.String>? = null, ebayOrderStatus: kotlin.String? = null, financialStatus: kotlin.String? = null, financialStatusIds: kotlin.collections.List<kotlin.String>? = null, fulfillmentStatus: kotlin.String? = null, returnStatus: kotlin.String? = null, fulfillmentChannel: kotlin.String? = null, shippingMethod: kotlin.String? = null, skipOrderIds: kotlin.String? = null, isDeleted: kotlin.Boolean? = null, shippingCountryIso3: kotlin.String? = null, deliveryMethod: kotlin.String? = null, shipNodeType: kotlin.String? = null, createdTo: kotlin.String? = null, createdFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, tags: kotlin.String? = null, sortBy: kotlin.String? = "order_id", sortDirection: kotlin.String? = "asc", params: kotlin.String? = "order_id,customer,totals,address,items,bundles,status", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, enableCache: kotlin.Boolean? = false, useLatestApiVersion: kotlin.Boolean? = false, roundingPrecision: kotlin.Int? = null) : ModelResponseOrderList {
        val localVarResponse = orderListWithHttpInfo(start = start, count = count, pageCursor = pageCursor, ids = ids, orderIds = orderIds, sinceId = sinceId, storeId = storeId, customerId = customerId, customerEmail = customerEmail, basketId = basketId, currencyId = currencyId, phone = phone, orderStatus = orderStatus, orderStatusIds = orderStatusIds, ebayOrderStatus = ebayOrderStatus, financialStatus = financialStatus, financialStatusIds = financialStatusIds, fulfillmentStatus = fulfillmentStatus, returnStatus = returnStatus, fulfillmentChannel = fulfillmentChannel, shippingMethod = shippingMethod, skipOrderIds = skipOrderIds, isDeleted = isDeleted, shippingCountryIso3 = shippingCountryIso3, deliveryMethod = deliveryMethod, shipNodeType = shipNodeType, createdTo = createdTo, createdFrom = createdFrom, modifiedTo = modifiedTo, modifiedFrom = modifiedFrom, tags = tags, sortBy = sortBy, sortDirection = sortDirection, params = params, responseFields = responseFields, exclude = exclude, enableCache = enableCache, useLatestApiVersion = useLatestApiVersion, roundingPrecision = roundingPrecision)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseOrderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.list
     * Get list of orders from store.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve orders via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param ids Retrieves orders specified by ids (optional)
     * @param orderIds Retrieves orders specified by order ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @param storeId Store Id (optional)
     * @param customerId Retrieves orders specified by customer id (optional)
     * @param customerEmail Retrieves orders specified by customer email (optional)
     * @param basketId Retrieves order’s info specified by basket id. (optional)
     * @param currencyId Currency Id (optional)
     * @param phone Filter orders by customer&#39;s phone number (optional)
     * @param orderStatus Retrieves orders specified by order status (optional)
     * @param orderStatusIds Retrieves orders specified by order statuses (optional)
     * @param ebayOrderStatus Retrieves orders specified by order status (optional)
     * @param financialStatus Retrieves orders specified by financial status (optional)
     * @param financialStatusIds Retrieves orders specified by financial status ids (optional)
     * @param fulfillmentStatus Create order with fulfillment status (optional)
     * @param returnStatus Retrieves orders specified by return status (optional)
     * @param fulfillmentChannel Retrieves order with a fulfillment channel (optional)
     * @param shippingMethod Retrieve entities according to shipping method (optional)
     * @param skipOrderIds Skipped orders by ids (optional)
     * @param isDeleted Filter deleted orders (optional)
     * @param shippingCountryIso3 Retrieve entities according to shipping country (optional)
     * @param deliveryMethod Retrieves order with delivery method (optional)
     * @param shipNodeType Retrieves order with ship node type (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param tags Order tags (optional)
     * @param sortBy Set field to sort by (optional, default to "order_id")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "order_id,customer,totals,address,items,bundles,status")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param enableCache If the value is &#39;true&#39;, we will cache orders for a 15 minutes in order to increase speed and reduce requests throttling for some methods and shoping platforms (for example order.shipment.add) (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param roundingPrecision &lt;p&gt;Specifies the rounding precision for fractional numeric values (such as prices, taxes, and weights).&lt;/p&gt; &lt;p&gt;Supported values range from &lt;b&gt;1&lt;/b&gt; to &lt;b&gt;6&lt;/b&gt;.&lt;/p&gt; &lt;p&gt;The default rounding precision may vary depending on the platform. You can retrieve the default value using the &lt;strong&gt;cart.info&lt;/strong&gt; method in the &lt;code&gt;default_rounding_precision&lt;/code&gt; field. &lt;/p&gt;&lt;p&gt;Values are rounded to the nearest number at the specified precision. Fractions of .5 or higher are rounded up, while fractions lower than .5 are rounded down.&lt;/p&gt; (optional)
     * @return ApiResponse<ModelResponseOrderList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, ids: kotlin.String?, orderIds: kotlin.String?, sinceId: kotlin.String?, storeId: kotlin.String?, customerId: kotlin.String?, customerEmail: kotlin.String?, basketId: kotlin.String?, currencyId: kotlin.String?, phone: kotlin.String?, orderStatus: kotlin.String?, orderStatusIds: kotlin.collections.List<kotlin.String>?, ebayOrderStatus: kotlin.String?, financialStatus: kotlin.String?, financialStatusIds: kotlin.collections.List<kotlin.String>?, fulfillmentStatus: kotlin.String?, returnStatus: kotlin.String?, fulfillmentChannel: kotlin.String?, shippingMethod: kotlin.String?, skipOrderIds: kotlin.String?, isDeleted: kotlin.Boolean?, shippingCountryIso3: kotlin.String?, deliveryMethod: kotlin.String?, shipNodeType: kotlin.String?, createdTo: kotlin.String?, createdFrom: kotlin.String?, modifiedTo: kotlin.String?, modifiedFrom: kotlin.String?, tags: kotlin.String?, sortBy: kotlin.String?, sortDirection: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, enableCache: kotlin.Boolean?, useLatestApiVersion: kotlin.Boolean?, roundingPrecision: kotlin.Int?) : ApiResponse<ModelResponseOrderList?> {
        val localVariableConfig = orderListRequestConfig(start = start, count = count, pageCursor = pageCursor, ids = ids, orderIds = orderIds, sinceId = sinceId, storeId = storeId, customerId = customerId, customerEmail = customerEmail, basketId = basketId, currencyId = currencyId, phone = phone, orderStatus = orderStatus, orderStatusIds = orderStatusIds, ebayOrderStatus = ebayOrderStatus, financialStatus = financialStatus, financialStatusIds = financialStatusIds, fulfillmentStatus = fulfillmentStatus, returnStatus = returnStatus, fulfillmentChannel = fulfillmentChannel, shippingMethod = shippingMethod, skipOrderIds = skipOrderIds, isDeleted = isDeleted, shippingCountryIso3 = shippingCountryIso3, deliveryMethod = deliveryMethod, shipNodeType = shipNodeType, createdTo = createdTo, createdFrom = createdFrom, modifiedTo = modifiedTo, modifiedFrom = modifiedFrom, tags = tags, sortBy = sortBy, sortDirection = sortDirection, params = params, responseFields = responseFields, exclude = exclude, enableCache = enableCache, useLatestApiVersion = useLatestApiVersion, roundingPrecision = roundingPrecision)

        return request<Unit, ModelResponseOrderList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve orders via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param ids Retrieves orders specified by ids (optional)
     * @param orderIds Retrieves orders specified by order ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @param storeId Store Id (optional)
     * @param customerId Retrieves orders specified by customer id (optional)
     * @param customerEmail Retrieves orders specified by customer email (optional)
     * @param basketId Retrieves order’s info specified by basket id. (optional)
     * @param currencyId Currency Id (optional)
     * @param phone Filter orders by customer&#39;s phone number (optional)
     * @param orderStatus Retrieves orders specified by order status (optional)
     * @param orderStatusIds Retrieves orders specified by order statuses (optional)
     * @param ebayOrderStatus Retrieves orders specified by order status (optional)
     * @param financialStatus Retrieves orders specified by financial status (optional)
     * @param financialStatusIds Retrieves orders specified by financial status ids (optional)
     * @param fulfillmentStatus Create order with fulfillment status (optional)
     * @param returnStatus Retrieves orders specified by return status (optional)
     * @param fulfillmentChannel Retrieves order with a fulfillment channel (optional)
     * @param shippingMethod Retrieve entities according to shipping method (optional)
     * @param skipOrderIds Skipped orders by ids (optional)
     * @param isDeleted Filter deleted orders (optional)
     * @param shippingCountryIso3 Retrieve entities according to shipping country (optional)
     * @param deliveryMethod Retrieves order with delivery method (optional)
     * @param shipNodeType Retrieves order with ship node type (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param tags Order tags (optional)
     * @param sortBy Set field to sort by (optional, default to "order_id")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "order_id,customer,totals,address,items,bundles,status")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param enableCache If the value is &#39;true&#39;, we will cache orders for a 15 minutes in order to increase speed and reduce requests throttling for some methods and shoping platforms (for example order.shipment.add) (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param roundingPrecision &lt;p&gt;Specifies the rounding precision for fractional numeric values (such as prices, taxes, and weights).&lt;/p&gt; &lt;p&gt;Supported values range from &lt;b&gt;1&lt;/b&gt; to &lt;b&gt;6&lt;/b&gt;.&lt;/p&gt; &lt;p&gt;The default rounding precision may vary depending on the platform. You can retrieve the default value using the &lt;strong&gt;cart.info&lt;/strong&gt; method in the &lt;code&gt;default_rounding_precision&lt;/code&gt; field. &lt;/p&gt;&lt;p&gt;Values are rounded to the nearest number at the specified precision. Fractions of .5 or higher are rounded up, while fractions lower than .5 are rounded down.&lt;/p&gt; (optional)
     * @return RequestConfig
     */
    fun orderListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, ids: kotlin.String?, orderIds: kotlin.String?, sinceId: kotlin.String?, storeId: kotlin.String?, customerId: kotlin.String?, customerEmail: kotlin.String?, basketId: kotlin.String?, currencyId: kotlin.String?, phone: kotlin.String?, orderStatus: kotlin.String?, orderStatusIds: kotlin.collections.List<kotlin.String>?, ebayOrderStatus: kotlin.String?, financialStatus: kotlin.String?, financialStatusIds: kotlin.collections.List<kotlin.String>?, fulfillmentStatus: kotlin.String?, returnStatus: kotlin.String?, fulfillmentChannel: kotlin.String?, shippingMethod: kotlin.String?, skipOrderIds: kotlin.String?, isDeleted: kotlin.Boolean?, shippingCountryIso3: kotlin.String?, deliveryMethod: kotlin.String?, shipNodeType: kotlin.String?, createdTo: kotlin.String?, createdFrom: kotlin.String?, modifiedTo: kotlin.String?, modifiedFrom: kotlin.String?, tags: kotlin.String?, sortBy: kotlin.String?, sortDirection: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, enableCache: kotlin.Boolean?, useLatestApiVersion: kotlin.Boolean?, roundingPrecision: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (ids != null) {
                    put("ids", listOf(ids.toString()))
                }
                if (orderIds != null) {
                    put("order_ids", listOf(orderIds.toString()))
                }
                if (sinceId != null) {
                    put("since_id", listOf(sinceId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (customerId != null) {
                    put("customer_id", listOf(customerId.toString()))
                }
                if (customerEmail != null) {
                    put("customer_email", listOf(customerEmail.toString()))
                }
                if (basketId != null) {
                    put("basket_id", listOf(basketId.toString()))
                }
                if (currencyId != null) {
                    put("currency_id", listOf(currencyId.toString()))
                }
                if (phone != null) {
                    put("phone", listOf(phone.toString()))
                }
                if (orderStatus != null) {
                    put("order_status", listOf(orderStatus.toString()))
                }
                if (orderStatusIds != null) {
                    put("order_status_ids", toMultiValue(orderStatusIds.toList(), "multi"))
                }
                if (ebayOrderStatus != null) {
                    put("ebay_order_status", listOf(ebayOrderStatus.toString()))
                }
                if (financialStatus != null) {
                    put("financial_status", listOf(financialStatus.toString()))
                }
                if (financialStatusIds != null) {
                    put("financial_status_ids", toMultiValue(financialStatusIds.toList(), "multi"))
                }
                if (fulfillmentStatus != null) {
                    put("fulfillment_status", listOf(fulfillmentStatus.toString()))
                }
                if (returnStatus != null) {
                    put("return_status", listOf(returnStatus.toString()))
                }
                if (fulfillmentChannel != null) {
                    put("fulfillment_channel", listOf(fulfillmentChannel.toString()))
                }
                if (shippingMethod != null) {
                    put("shipping_method", listOf(shippingMethod.toString()))
                }
                if (skipOrderIds != null) {
                    put("skip_order_ids", listOf(skipOrderIds.toString()))
                }
                if (isDeleted != null) {
                    put("is_deleted", listOf(isDeleted.toString()))
                }
                if (shippingCountryIso3 != null) {
                    put("shipping_country_iso3", listOf(shippingCountryIso3.toString()))
                }
                if (deliveryMethod != null) {
                    put("delivery_method", listOf(deliveryMethod.toString()))
                }
                if (shipNodeType != null) {
                    put("ship_node_type", listOf(shipNodeType.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (sortBy != null) {
                    put("sort_by", listOf(sortBy.toString()))
                }
                if (sortDirection != null) {
                    put("sort_direction", listOf(sortDirection.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (enableCache != null) {
                    put("enable_cache", listOf(enableCache.toString()))
                }
                if (useLatestApiVersion != null) {
                    put("use_latest_api_version", listOf(useLatestApiVersion.toString()))
                }
                if (roundingPrecision != null) {
                    put("rounding_precision", listOf(roundingPrecision.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.preestimate_shipping.list
     * Retrieve list of order preestimated shipping methods
     * @param orderPreestimateShippingList 
     * @return ModelResponseOrderPreestimateShippingList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderPreestimateShippingList(orderPreestimateShippingList: OrderPreestimateShippingList) : ModelResponseOrderPreestimateShippingList {
        val localVarResponse = orderPreestimateShippingListWithHttpInfo(orderPreestimateShippingList = orderPreestimateShippingList)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseOrderPreestimateShippingList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.preestimate_shipping.list
     * Retrieve list of order preestimated shipping methods
     * @param orderPreestimateShippingList 
     * @return ApiResponse<ModelResponseOrderPreestimateShippingList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderPreestimateShippingListWithHttpInfo(orderPreestimateShippingList: OrderPreestimateShippingList) : ApiResponse<ModelResponseOrderPreestimateShippingList?> {
        val localVariableConfig = orderPreestimateShippingListRequestConfig(orderPreestimateShippingList = orderPreestimateShippingList)

        return request<OrderPreestimateShippingList, ModelResponseOrderPreestimateShippingList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderPreestimateShippingList
     *
     * @param orderPreestimateShippingList 
     * @return RequestConfig
     */
    fun orderPreestimateShippingListRequestConfig(orderPreestimateShippingList: OrderPreestimateShippingList) : RequestConfig<OrderPreestimateShippingList> {
        val localVariableBody = orderPreestimateShippingList
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order.preestimate_shipping.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.refund.add
     * Add a refund to the order.
     * @param orderRefundAdd 
     * @return OrderRefundAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderRefundAdd(orderRefundAdd: OrderRefundAdd) : OrderRefundAdd200Response {
        val localVarResponse = orderRefundAddWithHttpInfo(orderRefundAdd = orderRefundAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderRefundAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.refund.add
     * Add a refund to the order.
     * @param orderRefundAdd 
     * @return ApiResponse<OrderRefundAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderRefundAddWithHttpInfo(orderRefundAdd: OrderRefundAdd) : ApiResponse<OrderRefundAdd200Response?> {
        val localVariableConfig = orderRefundAddRequestConfig(orderRefundAdd = orderRefundAdd)

        return request<OrderRefundAdd, OrderRefundAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderRefundAdd
     *
     * @param orderRefundAdd 
     * @return RequestConfig
     */
    fun orderRefundAddRequestConfig(orderRefundAdd: OrderRefundAdd) : RequestConfig<OrderRefundAdd> {
        val localVariableBody = orderRefundAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order.refund.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.return.add
     * Create new return request.
     * @param orderReturnAdd 
     * @return OrderReturnAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderReturnAdd(orderReturnAdd: OrderReturnAdd) : OrderReturnAdd200Response {
        val localVarResponse = orderReturnAddWithHttpInfo(orderReturnAdd = orderReturnAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderReturnAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.return.add
     * Create new return request.
     * @param orderReturnAdd 
     * @return ApiResponse<OrderReturnAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderReturnAddWithHttpInfo(orderReturnAdd: OrderReturnAdd) : ApiResponse<OrderReturnAdd200Response?> {
        val localVariableConfig = orderReturnAddRequestConfig(orderReturnAdd = orderReturnAdd)

        return request<OrderReturnAdd, OrderReturnAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderReturnAdd
     *
     * @param orderReturnAdd 
     * @return RequestConfig
     */
    fun orderReturnAddRequestConfig(orderReturnAdd: OrderReturnAdd) : RequestConfig<OrderReturnAdd> {
        val localVariableBody = orderReturnAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order.return.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.return.delete
     * Delete return.
     * @param returnId Return ID
     * @param orderId Defines the order id
     * @param storeId Store Id (optional)
     * @return AttributeValueDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderReturnDelete(returnId: kotlin.String, orderId: kotlin.String, storeId: kotlin.String? = null) : AttributeValueDelete200Response {
        val localVarResponse = orderReturnDeleteWithHttpInfo(returnId = returnId, orderId = orderId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeValueDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.return.delete
     * Delete return.
     * @param returnId Return ID
     * @param orderId Defines the order id
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeValueDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderReturnDeleteWithHttpInfo(returnId: kotlin.String, orderId: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeValueDelete200Response?> {
        val localVariableConfig = orderReturnDeleteRequestConfig(returnId = returnId, orderId = orderId, storeId = storeId)

        return request<Unit, AttributeValueDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderReturnDelete
     *
     * @param returnId Return ID
     * @param orderId Defines the order id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun orderReturnDeleteRequestConfig(returnId: kotlin.String, orderId: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("return_id", listOf(returnId.toString()))
                put("order_id", listOf(orderId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/order.return.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.return.update
     * Update order&#39;s shipment information.
     * @param orderReturnUpdate 
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderReturnUpdate(orderReturnUpdate: OrderReturnUpdate) : AccountConfigUpdate200Response {
        val localVarResponse = orderReturnUpdateWithHttpInfo(orderReturnUpdate = orderReturnUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.return.update
     * Update order&#39;s shipment information.
     * @param orderReturnUpdate 
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderReturnUpdateWithHttpInfo(orderReturnUpdate: OrderReturnUpdate) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = orderReturnUpdateRequestConfig(orderReturnUpdate = orderReturnUpdate)

        return request<OrderReturnUpdate, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderReturnUpdate
     *
     * @param orderReturnUpdate 
     * @return RequestConfig
     */
    fun orderReturnUpdateRequestConfig(orderReturnUpdate: OrderReturnUpdate) : RequestConfig<OrderReturnUpdate> {
        val localVariableBody = orderReturnUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/order.return.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.shipment.add
     * Add a shipment to the order.
     * @param orderShipmentAdd 
     * @return OrderShipmentAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderShipmentAdd(orderShipmentAdd: OrderShipmentAdd) : OrderShipmentAdd200Response {
        val localVarResponse = orderShipmentAddWithHttpInfo(orderShipmentAdd = orderShipmentAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderShipmentAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.shipment.add
     * Add a shipment to the order.
     * @param orderShipmentAdd 
     * @return ApiResponse<OrderShipmentAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderShipmentAddWithHttpInfo(orderShipmentAdd: OrderShipmentAdd) : ApiResponse<OrderShipmentAdd200Response?> {
        val localVariableConfig = orderShipmentAddRequestConfig(orderShipmentAdd = orderShipmentAdd)

        return request<OrderShipmentAdd, OrderShipmentAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderShipmentAdd
     *
     * @param orderShipmentAdd 
     * @return RequestConfig
     */
    fun orderShipmentAddRequestConfig(orderShipmentAdd: OrderShipmentAdd) : RequestConfig<OrderShipmentAdd> {
        val localVariableBody = orderShipmentAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order.shipment.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.shipment.add.batch
     * Add a shipments to the orders.
     * @param orderShipmentAddBatch 
     * @return CategoryAddBatch200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderShipmentAddBatch(orderShipmentAddBatch: OrderShipmentAddBatch) : CategoryAddBatch200Response {
        val localVarResponse = orderShipmentAddBatchWithHttpInfo(orderShipmentAddBatch = orderShipmentAddBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryAddBatch200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.shipment.add.batch
     * Add a shipments to the orders.
     * @param orderShipmentAddBatch 
     * @return ApiResponse<CategoryAddBatch200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderShipmentAddBatchWithHttpInfo(orderShipmentAddBatch: OrderShipmentAddBatch) : ApiResponse<CategoryAddBatch200Response?> {
        val localVariableConfig = orderShipmentAddBatchRequestConfig(orderShipmentAddBatch = orderShipmentAddBatch)

        return request<OrderShipmentAddBatch, CategoryAddBatch200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderShipmentAddBatch
     *
     * @param orderShipmentAddBatch 
     * @return RequestConfig
     */
    fun orderShipmentAddBatchRequestConfig(orderShipmentAddBatch: OrderShipmentAddBatch) : RequestConfig<OrderShipmentAddBatch> {
        val localVariableBody = orderShipmentAddBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order.shipment.add.batch.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.shipment.delete
     * Delete order&#39;s shipment.
     * @param shipmentId Shipment id indicates the number of delivery
     * @param orderId Defines the order for which the shipment will be deleted
     * @param storeId Store Id (optional)
     * @return OrderShipmentDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderShipmentDelete(shipmentId: kotlin.String, orderId: kotlin.String, storeId: kotlin.String? = null) : OrderShipmentDelete200Response {
        val localVarResponse = orderShipmentDeleteWithHttpInfo(shipmentId = shipmentId, orderId = orderId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderShipmentDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.shipment.delete
     * Delete order&#39;s shipment.
     * @param shipmentId Shipment id indicates the number of delivery
     * @param orderId Defines the order for which the shipment will be deleted
     * @param storeId Store Id (optional)
     * @return ApiResponse<OrderShipmentDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderShipmentDeleteWithHttpInfo(shipmentId: kotlin.String, orderId: kotlin.String, storeId: kotlin.String?) : ApiResponse<OrderShipmentDelete200Response?> {
        val localVariableConfig = orderShipmentDeleteRequestConfig(shipmentId = shipmentId, orderId = orderId, storeId = storeId)

        return request<Unit, OrderShipmentDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderShipmentDelete
     *
     * @param shipmentId Shipment id indicates the number of delivery
     * @param orderId Defines the order for which the shipment will be deleted
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun orderShipmentDeleteRequestConfig(shipmentId: kotlin.String, orderId: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("shipment_id", listOf(shipmentId.toString()))
                put("order_id", listOf(orderId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/order.shipment.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.shipment.info
     * Get information of shipment.
     * @param id Entity id
     * @param orderId Defines the order id
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,order_id,items,tracking_numbers")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return OrderShipmentInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderShipmentInfo(id: kotlin.String, orderId: kotlin.String, start: kotlin.Int? = 0, storeId: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "id,order_id,items,tracking_numbers", exclude: kotlin.String? = null) : OrderShipmentInfo200Response {
        val localVarResponse = orderShipmentInfoWithHttpInfo(id = id, orderId = orderId, start = start, storeId = storeId, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderShipmentInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.shipment.info
     * Get information of shipment.
     * @param id Entity id
     * @param orderId Defines the order id
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,order_id,items,tracking_numbers")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<OrderShipmentInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderShipmentInfoWithHttpInfo(id: kotlin.String, orderId: kotlin.String, start: kotlin.Int?, storeId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<OrderShipmentInfo200Response?> {
        val localVariableConfig = orderShipmentInfoRequestConfig(id = id, orderId = orderId, start = start, storeId = storeId, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, OrderShipmentInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderShipmentInfo
     *
     * @param id Entity id
     * @param orderId Defines the order id
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,order_id,items,tracking_numbers")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun orderShipmentInfoRequestConfig(id: kotlin.String, orderId: kotlin.String, start: kotlin.Int?, storeId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                put("id", listOf(id.toString()))
                put("order_id", listOf(orderId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.shipment.info.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.shipment.list
     * Get list of shipments per order.
     * @param orderId Retrieves shipments specified by order id
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,order_id,items,tracking_numbers")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseOrderShipmentList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderShipmentList(orderId: kotlin.String, start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, storeId: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "id,order_id,items,tracking_numbers", exclude: kotlin.String? = null) : ModelResponseOrderShipmentList {
        val localVarResponse = orderShipmentListWithHttpInfo(orderId = orderId, start = start, count = count, pageCursor = pageCursor, storeId = storeId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseOrderShipmentList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.shipment.list
     * Get list of shipments per order.
     * @param orderId Retrieves shipments specified by order id
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,order_id,items,tracking_numbers")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseOrderShipmentList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderShipmentListWithHttpInfo(orderId: kotlin.String, start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, storeId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseOrderShipmentList?> {
        val localVariableConfig = orderShipmentListRequestConfig(orderId = orderId, start = start, count = count, pageCursor = pageCursor, storeId = storeId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseOrderShipmentList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderShipmentList
     *
     * @param orderId Retrieves shipments specified by order id
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,order_id,items,tracking_numbers")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun orderShipmentListRequestConfig(orderId: kotlin.String, start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, storeId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                put("order_id", listOf(orderId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.shipment.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.shipment.tracking.add
     * Add order shipment&#39;s tracking info.
     * @param orderShipmentTrackingAdd 
     * @return OrderShipmentTrackingAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderShipmentTrackingAdd(orderShipmentTrackingAdd: OrderShipmentTrackingAdd) : OrderShipmentTrackingAdd200Response {
        val localVarResponse = orderShipmentTrackingAddWithHttpInfo(orderShipmentTrackingAdd = orderShipmentTrackingAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderShipmentTrackingAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.shipment.tracking.add
     * Add order shipment&#39;s tracking info.
     * @param orderShipmentTrackingAdd 
     * @return ApiResponse<OrderShipmentTrackingAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderShipmentTrackingAddWithHttpInfo(orderShipmentTrackingAdd: OrderShipmentTrackingAdd) : ApiResponse<OrderShipmentTrackingAdd200Response?> {
        val localVariableConfig = orderShipmentTrackingAddRequestConfig(orderShipmentTrackingAdd = orderShipmentTrackingAdd)

        return request<OrderShipmentTrackingAdd, OrderShipmentTrackingAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderShipmentTrackingAdd
     *
     * @param orderShipmentTrackingAdd 
     * @return RequestConfig
     */
    fun orderShipmentTrackingAddRequestConfig(orderShipmentTrackingAdd: OrderShipmentTrackingAdd) : RequestConfig<OrderShipmentTrackingAdd> {
        val localVariableBody = orderShipmentTrackingAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order.shipment.tracking.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.shipment.update
     * Update order&#39;s shipment information.
     * @param orderShipmentUpdate 
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderShipmentUpdate(orderShipmentUpdate: OrderShipmentUpdate) : AccountConfigUpdate200Response {
        val localVarResponse = orderShipmentUpdateWithHttpInfo(orderShipmentUpdate = orderShipmentUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.shipment.update
     * Update order&#39;s shipment information.
     * @param orderShipmentUpdate 
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderShipmentUpdateWithHttpInfo(orderShipmentUpdate: OrderShipmentUpdate) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = orderShipmentUpdateRequestConfig(orderShipmentUpdate = orderShipmentUpdate)

        return request<OrderShipmentUpdate, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderShipmentUpdate
     *
     * @param orderShipmentUpdate 
     * @return RequestConfig
     */
    fun orderShipmentUpdateRequestConfig(orderShipmentUpdate: OrderShipmentUpdate) : RequestConfig<OrderShipmentUpdate> {
        val localVariableBody = orderShipmentUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/order.shipment.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.status.list
     * Retrieve list of statuses
     * @param storeId Store Id (optional)
     * @param action Available statuses for the specified action. (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return ModelResponseOrderStatusList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderStatusList(storeId: kotlin.String? = null, action: kotlin.String? = null, responseFields: kotlin.String? = null) : ModelResponseOrderStatusList {
        val localVarResponse = orderStatusListWithHttpInfo(storeId = storeId, action = action, responseFields = responseFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseOrderStatusList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.status.list
     * Retrieve list of statuses
     * @param storeId Store Id (optional)
     * @param action Available statuses for the specified action. (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return ApiResponse<ModelResponseOrderStatusList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderStatusListWithHttpInfo(storeId: kotlin.String?, action: kotlin.String?, responseFields: kotlin.String?) : ApiResponse<ModelResponseOrderStatusList?> {
        val localVariableConfig = orderStatusListRequestConfig(storeId = storeId, action = action, responseFields = responseFields)

        return request<Unit, ModelResponseOrderStatusList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderStatusList
     *
     * @param storeId Store Id (optional)
     * @param action Available statuses for the specified action. (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return RequestConfig
     */
    fun orderStatusListRequestConfig(storeId: kotlin.String?, action: kotlin.String?, responseFields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (action != null) {
                    put("action", listOf(action.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.status.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.transaction.list
     * Retrieve list of order transaction
     * @param orderIds Retrieves order transactions specified by order ids
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,order_id,amount,description")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseOrderTransactionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderTransactionList(orderIds: kotlin.String, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, storeId: kotlin.String? = null, params: kotlin.String? = "id,order_id,amount,description", responseFields: kotlin.String? = null, exclude: kotlin.String? = null) : ModelResponseOrderTransactionList {
        val localVarResponse = orderTransactionListWithHttpInfo(orderIds = orderIds, count = count, pageCursor = pageCursor, storeId = storeId, params = params, responseFields = responseFields, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseOrderTransactionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.transaction.list
     * Retrieve list of order transaction
     * @param orderIds Retrieves order transactions specified by order ids
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,order_id,amount,description")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseOrderTransactionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderTransactionListWithHttpInfo(orderIds: kotlin.String, count: kotlin.Int?, pageCursor: kotlin.String?, storeId: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseOrderTransactionList?> {
        val localVariableConfig = orderTransactionListRequestConfig(orderIds = orderIds, count = count, pageCursor = pageCursor, storeId = storeId, params = params, responseFields = responseFields, exclude = exclude)

        return request<Unit, ModelResponseOrderTransactionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderTransactionList
     *
     * @param orderIds Retrieves order transactions specified by order ids
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,order_id,amount,description")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun orderTransactionListRequestConfig(orderIds: kotlin.String, count: kotlin.Int?, pageCursor: kotlin.String?, storeId: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                put("order_ids", listOf(orderIds.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order.transaction.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * order.update
     * Update existing order.
     * @param orderId Defines the orders specified by order id
     * @param storeId Defines store id where the order should be found (optional)
     * @param orderStatus Defines new order&#39;s status (optional)
     * @param financialStatus Update order financial status to specified (optional)
     * @param fulfillmentStatus Create order with fulfillment status (optional)
     * @param cancellationReason Defines the cancellation reason when the order will be canceled (optional)
     * @param orderPaymentMethod Defines order payment method.&lt;br/&gt;Setting order_payment_method on Shopify will also change financial_status field value to &#39;paid&#39; (optional)
     * @param comment Specifies order comment (optional)
     * @param adminComment Specifies admin&#39;s order comment (optional)
     * @param adminPrivateComment Specifies private admin&#39;s order comment (optional)
     * @param invoiceAdminComment Specifies admin&#39;s order invoice comment (optional)
     * @param dateModified Specifies order&#39;s  modification date (optional)
     * @param dateFinished Specifies order&#39;s  finished date (optional)
     * @param sendNotifications Send notifications to customer after order was created (optional, default to false)
     * @param createInvoice Determines whether an invoice should be created if it has not already been created (optional)
     * @param origin The source of the order (optional)
     * @param tags Order tags (optional)
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun orderUpdate(orderId: kotlin.String, storeId: kotlin.String? = null, orderStatus: kotlin.String? = null, financialStatus: kotlin.String? = null, fulfillmentStatus: kotlin.String? = null, cancellationReason: kotlin.String? = null, orderPaymentMethod: kotlin.String? = null, comment: kotlin.String? = null, adminComment: kotlin.String? = null, adminPrivateComment: kotlin.String? = null, invoiceAdminComment: kotlin.String? = null, dateModified: kotlin.String? = null, dateFinished: kotlin.String? = null, sendNotifications: kotlin.Boolean? = false, createInvoice: kotlin.Boolean? = null, origin: kotlin.String? = null, tags: kotlin.String? = null) : AccountConfigUpdate200Response {
        val localVarResponse = orderUpdateWithHttpInfo(orderId = orderId, storeId = storeId, orderStatus = orderStatus, financialStatus = financialStatus, fulfillmentStatus = fulfillmentStatus, cancellationReason = cancellationReason, orderPaymentMethod = orderPaymentMethod, comment = comment, adminComment = adminComment, adminPrivateComment = adminPrivateComment, invoiceAdminComment = invoiceAdminComment, dateModified = dateModified, dateFinished = dateFinished, sendNotifications = sendNotifications, createInvoice = createInvoice, origin = origin, tags = tags)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * order.update
     * Update existing order.
     * @param orderId Defines the orders specified by order id
     * @param storeId Defines store id where the order should be found (optional)
     * @param orderStatus Defines new order&#39;s status (optional)
     * @param financialStatus Update order financial status to specified (optional)
     * @param fulfillmentStatus Create order with fulfillment status (optional)
     * @param cancellationReason Defines the cancellation reason when the order will be canceled (optional)
     * @param orderPaymentMethod Defines order payment method.&lt;br/&gt;Setting order_payment_method on Shopify will also change financial_status field value to &#39;paid&#39; (optional)
     * @param comment Specifies order comment (optional)
     * @param adminComment Specifies admin&#39;s order comment (optional)
     * @param adminPrivateComment Specifies private admin&#39;s order comment (optional)
     * @param invoiceAdminComment Specifies admin&#39;s order invoice comment (optional)
     * @param dateModified Specifies order&#39;s  modification date (optional)
     * @param dateFinished Specifies order&#39;s  finished date (optional)
     * @param sendNotifications Send notifications to customer after order was created (optional, default to false)
     * @param createInvoice Determines whether an invoice should be created if it has not already been created (optional)
     * @param origin The source of the order (optional)
     * @param tags Order tags (optional)
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun orderUpdateWithHttpInfo(orderId: kotlin.String, storeId: kotlin.String?, orderStatus: kotlin.String?, financialStatus: kotlin.String?, fulfillmentStatus: kotlin.String?, cancellationReason: kotlin.String?, orderPaymentMethod: kotlin.String?, comment: kotlin.String?, adminComment: kotlin.String?, adminPrivateComment: kotlin.String?, invoiceAdminComment: kotlin.String?, dateModified: kotlin.String?, dateFinished: kotlin.String?, sendNotifications: kotlin.Boolean?, createInvoice: kotlin.Boolean?, origin: kotlin.String?, tags: kotlin.String?) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = orderUpdateRequestConfig(orderId = orderId, storeId = storeId, orderStatus = orderStatus, financialStatus = financialStatus, fulfillmentStatus = fulfillmentStatus, cancellationReason = cancellationReason, orderPaymentMethod = orderPaymentMethod, comment = comment, adminComment = adminComment, adminPrivateComment = adminPrivateComment, invoiceAdminComment = invoiceAdminComment, dateModified = dateModified, dateFinished = dateFinished, sendNotifications = sendNotifications, createInvoice = createInvoice, origin = origin, tags = tags)

        return request<Unit, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderUpdate
     *
     * @param orderId Defines the orders specified by order id
     * @param storeId Defines store id where the order should be found (optional)
     * @param orderStatus Defines new order&#39;s status (optional)
     * @param financialStatus Update order financial status to specified (optional)
     * @param fulfillmentStatus Create order with fulfillment status (optional)
     * @param cancellationReason Defines the cancellation reason when the order will be canceled (optional)
     * @param orderPaymentMethod Defines order payment method.&lt;br/&gt;Setting order_payment_method on Shopify will also change financial_status field value to &#39;paid&#39; (optional)
     * @param comment Specifies order comment (optional)
     * @param adminComment Specifies admin&#39;s order comment (optional)
     * @param adminPrivateComment Specifies private admin&#39;s order comment (optional)
     * @param invoiceAdminComment Specifies admin&#39;s order invoice comment (optional)
     * @param dateModified Specifies order&#39;s  modification date (optional)
     * @param dateFinished Specifies order&#39;s  finished date (optional)
     * @param sendNotifications Send notifications to customer after order was created (optional, default to false)
     * @param createInvoice Determines whether an invoice should be created if it has not already been created (optional)
     * @param origin The source of the order (optional)
     * @param tags Order tags (optional)
     * @return RequestConfig
     */
    fun orderUpdateRequestConfig(orderId: kotlin.String, storeId: kotlin.String?, orderStatus: kotlin.String?, financialStatus: kotlin.String?, fulfillmentStatus: kotlin.String?, cancellationReason: kotlin.String?, orderPaymentMethod: kotlin.String?, comment: kotlin.String?, adminComment: kotlin.String?, adminPrivateComment: kotlin.String?, invoiceAdminComment: kotlin.String?, dateModified: kotlin.String?, dateFinished: kotlin.String?, sendNotifications: kotlin.Boolean?, createInvoice: kotlin.Boolean?, origin: kotlin.String?, tags: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("order_id", listOf(orderId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (orderStatus != null) {
                    put("order_status", listOf(orderStatus.toString()))
                }
                if (financialStatus != null) {
                    put("financial_status", listOf(financialStatus.toString()))
                }
                if (fulfillmentStatus != null) {
                    put("fulfillment_status", listOf(fulfillmentStatus.toString()))
                }
                if (cancellationReason != null) {
                    put("cancellation_reason", listOf(cancellationReason.toString()))
                }
                if (orderPaymentMethod != null) {
                    put("order_payment_method", listOf(orderPaymentMethod.toString()))
                }
                if (comment != null) {
                    put("comment", listOf(comment.toString()))
                }
                if (adminComment != null) {
                    put("admin_comment", listOf(adminComment.toString()))
                }
                if (adminPrivateComment != null) {
                    put("admin_private_comment", listOf(adminPrivateComment.toString()))
                }
                if (invoiceAdminComment != null) {
                    put("invoice_admin_comment", listOf(invoiceAdminComment.toString()))
                }
                if (dateModified != null) {
                    put("date_modified", listOf(dateModified.toString()))
                }
                if (dateFinished != null) {
                    put("date_finished", listOf(dateFinished.toString()))
                }
                if (sendNotifications != null) {
                    put("send_notifications", listOf(sendNotifications.toString()))
                }
                if (createInvoice != null) {
                    put("create_invoice", listOf(createInvoice.toString()))
                }
                if (origin != null) {
                    put("origin", listOf(origin.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/order.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
