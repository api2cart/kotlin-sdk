/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountConfigUpdate200Response
import org.openapitools.client.models.AttributeAdd200Response
import org.openapitools.client.models.CustomerAdd
import org.openapitools.client.models.CustomerAdd200Response
import org.openapitools.client.models.CustomerAddressAdd
import org.openapitools.client.models.CustomerCount200Response
import org.openapitools.client.models.CustomerDelete200Response
import org.openapitools.client.models.CustomerFind200Response
import org.openapitools.client.models.CustomerGroupAdd200Response
import org.openapitools.client.models.CustomerInfo200Response
import org.openapitools.client.models.CustomerUpdate
import org.openapitools.client.models.ModelResponseCustomerAttributeList
import org.openapitools.client.models.ModelResponseCustomerGroupList
import org.openapitools.client.models.ModelResponseCustomerList
import org.openapitools.client.models.ModelResponseCustomerWishlistList

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class CustomerApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.api2cart.com/v1.1")
        }
    }

    /**
     * customer.add
     * Add customer into store.
     * @param customerAdd 
     * @return CustomerAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerAdd(customerAdd: CustomerAdd) : CustomerAdd200Response {
        val localVarResponse = customerAddWithHttpInfo(customerAdd = customerAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.add
     * Add customer into store.
     * @param customerAdd 
     * @return ApiResponse<CustomerAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerAddWithHttpInfo(customerAdd: CustomerAdd) : ApiResponse<CustomerAdd200Response?> {
        val localVariableConfig = customerAddRequestConfig(customerAdd = customerAdd)

        return request<CustomerAdd, CustomerAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerAdd
     *
     * @param customerAdd 
     * @return RequestConfig
     */
    fun customerAddRequestConfig(customerAdd: CustomerAdd) : RequestConfig<CustomerAdd> {
        val localVariableBody = customerAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/customer.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.address.add
     * Add customer address.
     * @param customerAddressAdd 
     * @return AttributeAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerAddressAdd(customerAddressAdd: CustomerAddressAdd) : AttributeAdd200Response {
        val localVarResponse = customerAddressAddWithHttpInfo(customerAddressAdd = customerAddressAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.address.add
     * Add customer address.
     * @param customerAddressAdd 
     * @return ApiResponse<AttributeAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerAddressAddWithHttpInfo(customerAddressAdd: CustomerAddressAdd) : ApiResponse<AttributeAdd200Response?> {
        val localVariableConfig = customerAddressAddRequestConfig(customerAddressAdd = customerAddressAdd)

        return request<CustomerAddressAdd, AttributeAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerAddressAdd
     *
     * @param customerAddressAdd 
     * @return RequestConfig
     */
    fun customerAddressAddRequestConfig(customerAddressAdd: CustomerAddressAdd) : RequestConfig<CustomerAddressAdd> {
        val localVariableBody = customerAddressAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/customer.address.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.attribute.list
     * Get attributes for specific customer
     * @param customerId Retrieves orders specified by customer id
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return ModelResponseCustomerAttributeList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerAttributeList(customerId: kotlin.String, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, params: kotlin.String? = "force_all", exclude: kotlin.String? = null, responseFields: kotlin.String? = null) : ModelResponseCustomerAttributeList {
        val localVarResponse = customerAttributeListWithHttpInfo(customerId = customerId, count = count, pageCursor = pageCursor, storeId = storeId, langId = langId, params = params, exclude = exclude, responseFields = responseFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCustomerAttributeList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.attribute.list
     * Get attributes for specific customer
     * @param customerId Retrieves orders specified by customer id
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return ApiResponse<ModelResponseCustomerAttributeList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerAttributeListWithHttpInfo(customerId: kotlin.String, count: kotlin.Int?, pageCursor: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?) : ApiResponse<ModelResponseCustomerAttributeList?> {
        val localVariableConfig = customerAttributeListRequestConfig(customerId = customerId, count = count, pageCursor = pageCursor, storeId = storeId, langId = langId, params = params, exclude = exclude, responseFields = responseFields)

        return request<Unit, ModelResponseCustomerAttributeList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerAttributeList
     *
     * @param customerId Retrieves orders specified by customer id
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return RequestConfig
     */
    fun customerAttributeListRequestConfig(customerId: kotlin.String, count: kotlin.Int?, pageCursor: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                put("customer_id", listOf(customerId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/customer.attribute.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.count
     * Get number of customers from store.
     * @param groupId Customer group_id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param storeId Counts customer specified by store id (optional)
     * @param customerListId The numeric ID of the customer list in Demandware. (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Counts customers that are searched specified by field (optional)
     * @param ids Counts customers specified by ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @return CustomerCount200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerCount(groupId: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, storeId: kotlin.String? = null, customerListId: kotlin.String? = null, avail: kotlin.Boolean? = true, findValue: kotlin.String? = null, findWhere: kotlin.String? = null, ids: kotlin.String? = null, sinceId: kotlin.String? = null) : CustomerCount200Response {
        val localVarResponse = customerCountWithHttpInfo(groupId = groupId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, storeId = storeId, customerListId = customerListId, avail = avail, findValue = findValue, findWhere = findWhere, ids = ids, sinceId = sinceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerCount200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.count
     * Get number of customers from store.
     * @param groupId Customer group_id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param storeId Counts customer specified by store id (optional)
     * @param customerListId The numeric ID of the customer list in Demandware. (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Counts customers that are searched specified by field (optional)
     * @param ids Counts customers specified by ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @return ApiResponse<CustomerCount200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerCountWithHttpInfo(groupId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, storeId: kotlin.String?, customerListId: kotlin.String?, avail: kotlin.Boolean?, findValue: kotlin.String?, findWhere: kotlin.String?, ids: kotlin.String?, sinceId: kotlin.String?) : ApiResponse<CustomerCount200Response?> {
        val localVariableConfig = customerCountRequestConfig(groupId = groupId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, storeId = storeId, customerListId = customerListId, avail = avail, findValue = findValue, findWhere = findWhere, ids = ids, sinceId = sinceId)

        return request<Unit, CustomerCount200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerCount
     *
     * @param groupId Customer group_id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param storeId Counts customer specified by store id (optional)
     * @param customerListId The numeric ID of the customer list in Demandware. (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Counts customers that are searched specified by field (optional)
     * @param ids Counts customers specified by ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @return RequestConfig
     */
    fun customerCountRequestConfig(groupId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, storeId: kotlin.String?, customerListId: kotlin.String?, avail: kotlin.Boolean?, findValue: kotlin.String?, findWhere: kotlin.String?, ids: kotlin.String?, sinceId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (groupId != null) {
                    put("group_id", listOf(groupId.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (customerListId != null) {
                    put("customer_list_id", listOf(customerListId.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
                if (findValue != null) {
                    put("find_value", listOf(findValue.toString()))
                }
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (ids != null) {
                    put("ids", listOf(ids.toString()))
                }
                if (sinceId != null) {
                    put("since_id", listOf(sinceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/customer.count.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.delete
     * Delete customer from store.
     * @param id Identifies customer specified by the id
     * @return CustomerDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerDelete(id: kotlin.String) : CustomerDelete200Response {
        val localVarResponse = customerDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.delete
     * Delete customer from store.
     * @param id Identifies customer specified by the id
     * @return ApiResponse<CustomerDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<CustomerDelete200Response?> {
        val localVariableConfig = customerDeleteRequestConfig(id = id)

        return request<Unit, CustomerDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerDelete
     *
     * @param id Identifies customer specified by the id
     * @return RequestConfig
     */
    fun customerDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/customer.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.find
     * Find customers in store.
     * @param findValue Entity search that is specified by some value
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional, default to "email")
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param storeId Store Id (optional)
     * @return CustomerFind200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerFind(findValue: kotlin.String, findWhere: kotlin.String? = "email", findParams: kotlin.String? = "whole_words", storeId: kotlin.String? = null) : CustomerFind200Response {
        val localVarResponse = customerFindWithHttpInfo(findValue = findValue, findWhere = findWhere, findParams = findParams, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerFind200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.find
     * Find customers in store.
     * @param findValue Entity search that is specified by some value
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional, default to "email")
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param storeId Store Id (optional)
     * @return ApiResponse<CustomerFind200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerFindWithHttpInfo(findValue: kotlin.String, findWhere: kotlin.String?, findParams: kotlin.String?, storeId: kotlin.String?) : ApiResponse<CustomerFind200Response?> {
        val localVariableConfig = customerFindRequestConfig(findValue = findValue, findWhere = findWhere, findParams = findParams, storeId = storeId)

        return request<Unit, CustomerFind200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerFind
     *
     * @param findValue Entity search that is specified by some value
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional, default to "email")
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun customerFindRequestConfig(findValue: kotlin.String, findWhere: kotlin.String?, findParams: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("find_value", listOf(findValue.toString()))
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (findParams != null) {
                    put("find_params", listOf(findParams.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/customer.find.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.group.add
     * Create customer group.
     * @param name Customer group name
     * @param storeId Store Id (optional)
     * @param storesIds Assign customer group to the stores that is specified by comma-separated stores&#39; id (optional)
     * @return CustomerGroupAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerGroupAdd(name: kotlin.String, storeId: kotlin.String? = null, storesIds: kotlin.String? = null) : CustomerGroupAdd200Response {
        val localVarResponse = customerGroupAddWithHttpInfo(name = name, storeId = storeId, storesIds = storesIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerGroupAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.group.add
     * Create customer group.
     * @param name Customer group name
     * @param storeId Store Id (optional)
     * @param storesIds Assign customer group to the stores that is specified by comma-separated stores&#39; id (optional)
     * @return ApiResponse<CustomerGroupAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerGroupAddWithHttpInfo(name: kotlin.String, storeId: kotlin.String?, storesIds: kotlin.String?) : ApiResponse<CustomerGroupAdd200Response?> {
        val localVariableConfig = customerGroupAddRequestConfig(name = name, storeId = storeId, storesIds = storesIds)

        return request<Unit, CustomerGroupAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerGroupAdd
     *
     * @param name Customer group name
     * @param storeId Store Id (optional)
     * @param storesIds Assign customer group to the stores that is specified by comma-separated stores&#39; id (optional)
     * @return RequestConfig
     */
    fun customerGroupAddRequestConfig(name: kotlin.String, storeId: kotlin.String?, storesIds: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("name", listOf(name.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (storesIds != null) {
                    put("stores_ids", listOf(storesIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/customer.group.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.group.list
     * Get list of customers groups.
     * @param disableCache Disable cache for current request (optional, default to false)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param groupIds Groups that will be assigned to a customer (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,additional_fields")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return ModelResponseCustomerGroupList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerGroupList(disableCache: kotlin.Boolean? = false, pageCursor: kotlin.String? = null, start: kotlin.Int? = 0, count: kotlin.Int? = 10, storeId: kotlin.String? = null, langId: kotlin.String? = null, groupIds: kotlin.String? = null, params: kotlin.String? = "id,name,additional_fields", exclude: kotlin.String? = null, responseFields: kotlin.String? = null) : ModelResponseCustomerGroupList {
        val localVarResponse = customerGroupListWithHttpInfo(disableCache = disableCache, pageCursor = pageCursor, start = start, count = count, storeId = storeId, langId = langId, groupIds = groupIds, params = params, exclude = exclude, responseFields = responseFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCustomerGroupList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.group.list
     * Get list of customers groups.
     * @param disableCache Disable cache for current request (optional, default to false)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param groupIds Groups that will be assigned to a customer (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,additional_fields")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return ApiResponse<ModelResponseCustomerGroupList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerGroupListWithHttpInfo(disableCache: kotlin.Boolean?, pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, storeId: kotlin.String?, langId: kotlin.String?, groupIds: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?) : ApiResponse<ModelResponseCustomerGroupList?> {
        val localVariableConfig = customerGroupListRequestConfig(disableCache = disableCache, pageCursor = pageCursor, start = start, count = count, storeId = storeId, langId = langId, groupIds = groupIds, params = params, exclude = exclude, responseFields = responseFields)

        return request<Unit, ModelResponseCustomerGroupList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerGroupList
     *
     * @param disableCache Disable cache for current request (optional, default to false)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param groupIds Groups that will be assigned to a customer (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,additional_fields")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return RequestConfig
     */
    fun customerGroupListRequestConfig(disableCache: kotlin.Boolean?, pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, storeId: kotlin.String?, langId: kotlin.String?, groupIds: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (disableCache != null) {
                    put("disable_cache", listOf(disableCache.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (groupIds != null) {
                    put("group_ids", listOf(groupIds.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/customer.group.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.info
     * Get customers&#39; details from store.
     * @param id Retrieves customer&#39;s info specified by customer id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,email,first_name,last_name")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves customer info specified by store id (optional)
     * @return CustomerInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerInfo(id: kotlin.String, params: kotlin.String? = "id,email,first_name,last_name", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, storeId: kotlin.String? = null) : CustomerInfo200Response {
        val localVarResponse = customerInfoWithHttpInfo(id = id, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.info
     * Get customers&#39; details from store.
     * @param id Retrieves customer&#39;s info specified by customer id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,email,first_name,last_name")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves customer info specified by store id (optional)
     * @return ApiResponse<CustomerInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerInfoWithHttpInfo(id: kotlin.String, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?) : ApiResponse<CustomerInfo200Response?> {
        val localVariableConfig = customerInfoRequestConfig(id = id, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId)

        return request<Unit, CustomerInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerInfo
     *
     * @param id Retrieves customer&#39;s info specified by customer id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,email,first_name,last_name")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves customer info specified by store id (optional)
     * @return RequestConfig
     */
    fun customerInfoRequestConfig(id: kotlin.String, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/customer.info.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.list
     * Get list of customers from store.
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,email,first_name,last_name")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param groupId Customer group_id (optional)
     * @param storeId Retrieves customers specified by store id (optional)
     * @param customerListId The numeric ID of the customer list in Demandware. (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Customer search that is specified by field (optional)
     * @param sortBy Set field to sort by (optional, default to "created_time")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param ids Retrieves customers specified by ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @return ModelResponseCustomerList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerList(pageCursor: kotlin.String? = null, start: kotlin.Int? = 0, count: kotlin.Int? = 10, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, params: kotlin.String? = "id,email,first_name,last_name", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, groupId: kotlin.String? = null, storeId: kotlin.String? = null, customerListId: kotlin.String? = null, avail: kotlin.Boolean? = true, findValue: kotlin.String? = null, findWhere: kotlin.String? = null, sortBy: kotlin.String? = "created_time", sortDirection: kotlin.String? = "asc", ids: kotlin.String? = null, sinceId: kotlin.String? = null) : ModelResponseCustomerList {
        val localVarResponse = customerListWithHttpInfo(pageCursor = pageCursor, start = start, count = count, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, params = params, responseFields = responseFields, exclude = exclude, groupId = groupId, storeId = storeId, customerListId = customerListId, avail = avail, findValue = findValue, findWhere = findWhere, sortBy = sortBy, sortDirection = sortDirection, ids = ids, sinceId = sinceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCustomerList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.list
     * Get list of customers from store.
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,email,first_name,last_name")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param groupId Customer group_id (optional)
     * @param storeId Retrieves customers specified by store id (optional)
     * @param customerListId The numeric ID of the customer list in Demandware. (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Customer search that is specified by field (optional)
     * @param sortBy Set field to sort by (optional, default to "created_time")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param ids Retrieves customers specified by ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @return ApiResponse<ModelResponseCustomerList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerListWithHttpInfo(pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, groupId: kotlin.String?, storeId: kotlin.String?, customerListId: kotlin.String?, avail: kotlin.Boolean?, findValue: kotlin.String?, findWhere: kotlin.String?, sortBy: kotlin.String?, sortDirection: kotlin.String?, ids: kotlin.String?, sinceId: kotlin.String?) : ApiResponse<ModelResponseCustomerList?> {
        val localVariableConfig = customerListRequestConfig(pageCursor = pageCursor, start = start, count = count, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, params = params, responseFields = responseFields, exclude = exclude, groupId = groupId, storeId = storeId, customerListId = customerListId, avail = avail, findValue = findValue, findWhere = findWhere, sortBy = sortBy, sortDirection = sortDirection, ids = ids, sinceId = sinceId)

        return request<Unit, ModelResponseCustomerList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerList
     *
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,email,first_name,last_name")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param groupId Customer group_id (optional)
     * @param storeId Retrieves customers specified by store id (optional)
     * @param customerListId The numeric ID of the customer list in Demandware. (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Customer search that is specified by field (optional)
     * @param sortBy Set field to sort by (optional, default to "created_time")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param ids Retrieves customers specified by ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @return RequestConfig
     */
    fun customerListRequestConfig(pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, groupId: kotlin.String?, storeId: kotlin.String?, customerListId: kotlin.String?, avail: kotlin.Boolean?, findValue: kotlin.String?, findWhere: kotlin.String?, sortBy: kotlin.String?, sortDirection: kotlin.String?, ids: kotlin.String?, sinceId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (groupId != null) {
                    put("group_id", listOf(groupId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (customerListId != null) {
                    put("customer_list_id", listOf(customerListId.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
                if (findValue != null) {
                    put("find_value", listOf(findValue.toString()))
                }
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (sortBy != null) {
                    put("sort_by", listOf(sortBy.toString()))
                }
                if (sortDirection != null) {
                    put("sort_direction", listOf(sortDirection.toString()))
                }
                if (ids != null) {
                    put("ids", listOf(ids.toString()))
                }
                if (sinceId != null) {
                    put("since_id", listOf(sinceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/customer.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.update
     * Update information of customer in store.
     * @param customerUpdate 
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerUpdate(customerUpdate: CustomerUpdate) : AccountConfigUpdate200Response {
        val localVarResponse = customerUpdateWithHttpInfo(customerUpdate = customerUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.update
     * Update information of customer in store.
     * @param customerUpdate 
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerUpdateWithHttpInfo(customerUpdate: CustomerUpdate) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = customerUpdateRequestConfig(customerUpdate = customerUpdate)

        return request<CustomerUpdate, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerUpdate
     *
     * @param customerUpdate 
     * @return RequestConfig
     */
    fun customerUpdateRequestConfig(customerUpdate: CustomerUpdate) : RequestConfig<CustomerUpdate> {
        val localVariableBody = customerUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/customer.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * customer.wishlist.list
     * Get a Wish List of customer from the store.
     * @param customerId Retrieves orders specified by customer id
     * @param id Entity id (optional)
     * @param storeId Store Id (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "{return_code,return_message,pagination,result}")
     * @return ModelResponseCustomerWishlistList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun customerWishlistList(customerId: kotlin.String, id: kotlin.String? = null, storeId: kotlin.String? = null, start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, responseFields: kotlin.String? = "{return_code,return_message,pagination,result}") : ModelResponseCustomerWishlistList {
        val localVarResponse = customerWishlistListWithHttpInfo(customerId = customerId, id = id, storeId = storeId, start = start, count = count, pageCursor = pageCursor, responseFields = responseFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCustomerWishlistList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * customer.wishlist.list
     * Get a Wish List of customer from the store.
     * @param customerId Retrieves orders specified by customer id
     * @param id Entity id (optional)
     * @param storeId Store Id (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "{return_code,return_message,pagination,result}")
     * @return ApiResponse<ModelResponseCustomerWishlistList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun customerWishlistListWithHttpInfo(customerId: kotlin.String, id: kotlin.String?, storeId: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, responseFields: kotlin.String?) : ApiResponse<ModelResponseCustomerWishlistList?> {
        val localVariableConfig = customerWishlistListRequestConfig(customerId = customerId, id = id, storeId = storeId, start = start, count = count, pageCursor = pageCursor, responseFields = responseFields)

        return request<Unit, ModelResponseCustomerWishlistList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation customerWishlistList
     *
     * @param customerId Retrieves orders specified by customer id
     * @param id Entity id (optional)
     * @param storeId Store Id (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "{return_code,return_message,pagination,result}")
     * @return RequestConfig
     */
    fun customerWishlistListRequestConfig(customerId: kotlin.String, id: kotlin.String?, storeId: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, responseFields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("customer_id", listOf(customerId.toString()))
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/customer.wishlist.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
