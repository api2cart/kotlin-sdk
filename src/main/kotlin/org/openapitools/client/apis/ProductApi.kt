/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountConfigUpdate200Response
import org.openapitools.client.models.AttributeDelete200Response
import org.openapitools.client.models.AttributeValueDelete200Response
import org.openapitools.client.models.CartConfigUpdate200Response
import org.openapitools.client.models.CartValidate200Response
import org.openapitools.client.models.CategoryAddBatch200Response
import org.openapitools.client.models.CustomerDelete200Response
import org.openapitools.client.models.ModelResponseProductAttributeList
import org.openapitools.client.models.ModelResponseProductBrandList
import org.openapitools.client.models.ModelResponseProductChildItemList
import org.openapitools.client.models.ModelResponseProductCurrencyList
import org.openapitools.client.models.ModelResponseProductList
import org.openapitools.client.models.ModelResponseProductOptionList
import org.openapitools.client.models.ModelResponseProductReviewList
import org.openapitools.client.models.ProductAdd
import org.openapitools.client.models.ProductAdd200Response
import org.openapitools.client.models.ProductAddBatch
import org.openapitools.client.models.ProductAttributeValueSet200Response
import org.openapitools.client.models.ProductAttributeValueUnset200Response
import org.openapitools.client.models.ProductChildItemFind200Response
import org.openapitools.client.models.ProductChildItemInfo200Response
import org.openapitools.client.models.ProductCount200Response
import org.openapitools.client.models.ProductCurrencyAdd200Response
import org.openapitools.client.models.ProductDeleteBatch
import org.openapitools.client.models.ProductFind200Response
import org.openapitools.client.models.ProductImageAdd
import org.openapitools.client.models.ProductImageAdd200Response
import org.openapitools.client.models.ProductImageUpdate200Response
import org.openapitools.client.models.ProductInfo200Response
import org.openapitools.client.models.ProductManufacturerAdd200Response
import org.openapitools.client.models.ProductOptionAdd
import org.openapitools.client.models.ProductOptionAdd200Response
import org.openapitools.client.models.ProductOptionAssign200Response
import org.openapitools.client.models.ProductOptionValueAdd200Response
import org.openapitools.client.models.ProductOptionValueAssign200Response
import org.openapitools.client.models.ProductPriceAdd
import org.openapitools.client.models.ProductPriceUpdate
import org.openapitools.client.models.ProductTaxAdd
import org.openapitools.client.models.ProductTaxAdd200Response
import org.openapitools.client.models.ProductUpdate
import org.openapitools.client.models.ProductUpdateBatch
import org.openapitools.client.models.ProductVariantAdd
import org.openapitools.client.models.ProductVariantAdd200Response
import org.openapitools.client.models.ProductVariantAddBatch
import org.openapitools.client.models.ProductVariantCount200Response
import org.openapitools.client.models.ProductVariantDeleteBatch
import org.openapitools.client.models.ProductVariantImageAdd
import org.openapitools.client.models.ProductVariantImageAdd200Response
import org.openapitools.client.models.ProductVariantList200Response
import org.openapitools.client.models.ProductVariantPriceAdd
import org.openapitools.client.models.ProductVariantPriceUpdate
import org.openapitools.client.models.ProductVariantUpdate
import org.openapitools.client.models.ProductVariantUpdateBatch

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ProductApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.api2cart.com/v1.1")
        }
    }

    /**
     * product.add
     * Add new product to store.
     * @param productAdd 
     * @return ProductAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productAdd(productAdd: ProductAdd) : ProductAdd200Response {
        val localVarResponse = productAddWithHttpInfo(productAdd = productAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.add
     * Add new product to store.
     * @param productAdd 
     * @return ApiResponse<ProductAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productAddWithHttpInfo(productAdd: ProductAdd) : ApiResponse<ProductAdd200Response?> {
        val localVariableConfig = productAddRequestConfig(productAdd = productAdd)

        return request<ProductAdd, ProductAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productAdd
     *
     * @param productAdd 
     * @return RequestConfig
     */
    fun productAddRequestConfig(productAdd: ProductAdd) : RequestConfig<ProductAdd> {
        val localVariableBody = productAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.add.batch
     * Add new products to the store.
     * @param productAddBatch 
     * @return CategoryAddBatch200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productAddBatch(productAddBatch: ProductAddBatch) : CategoryAddBatch200Response {
        val localVarResponse = productAddBatchWithHttpInfo(productAddBatch = productAddBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryAddBatch200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.add.batch
     * Add new products to the store.
     * @param productAddBatch 
     * @return ApiResponse<CategoryAddBatch200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productAddBatchWithHttpInfo(productAddBatch: ProductAddBatch) : ApiResponse<CategoryAddBatch200Response?> {
        val localVariableConfig = productAddBatchRequestConfig(productAddBatch = productAddBatch)

        return request<ProductAddBatch, CategoryAddBatch200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productAddBatch
     *
     * @param productAddBatch 
     * @return RequestConfig
     */
    fun productAddBatchRequestConfig(productAddBatch: ProductAddBatch) : RequestConfig<ProductAddBatch> {
        val localVariableBody = productAddBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.add.batch.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.attribute.list
     * Get list of attributes and values.
     * @param productId Retrieves attributes specified by product id
     * @param attributeId Retrieves info for specified attribute_id (optional)
     * @param variantId Defines product&#39;s variants specified by variant id (optional)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param attributeGroupId Filter by attribute_group_id (optional)
     * @param setName Retrieves attributes specified by set_name in Magento (optional)
     * @param langId Retrieves attributes specified by language id (optional)
     * @param storeId Retrieves attributes specified by store id (optional)
     * @param sortBy Set field to sort by (optional, default to "attribute_id")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "attribute_id,name")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseProductAttributeList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productAttributeList(productId: kotlin.String, attributeId: kotlin.String? = null, variantId: kotlin.String? = null, pageCursor: kotlin.String? = null, start: kotlin.Int? = 0, count: kotlin.Int? = 10, attributeGroupId: kotlin.String? = null, setName: kotlin.String? = null, langId: kotlin.String? = null, storeId: kotlin.String? = null, sortBy: kotlin.String? = "attribute_id", sortDirection: kotlin.String? = "asc", params: kotlin.String? = "attribute_id,name", responseFields: kotlin.String? = null, exclude: kotlin.String? = null) : ModelResponseProductAttributeList {
        val localVarResponse = productAttributeListWithHttpInfo(productId = productId, attributeId = attributeId, variantId = variantId, pageCursor = pageCursor, start = start, count = count, attributeGroupId = attributeGroupId, setName = setName, langId = langId, storeId = storeId, sortBy = sortBy, sortDirection = sortDirection, params = params, responseFields = responseFields, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseProductAttributeList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.attribute.list
     * Get list of attributes and values.
     * @param productId Retrieves attributes specified by product id
     * @param attributeId Retrieves info for specified attribute_id (optional)
     * @param variantId Defines product&#39;s variants specified by variant id (optional)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param attributeGroupId Filter by attribute_group_id (optional)
     * @param setName Retrieves attributes specified by set_name in Magento (optional)
     * @param langId Retrieves attributes specified by language id (optional)
     * @param storeId Retrieves attributes specified by store id (optional)
     * @param sortBy Set field to sort by (optional, default to "attribute_id")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "attribute_id,name")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseProductAttributeList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productAttributeListWithHttpInfo(productId: kotlin.String, attributeId: kotlin.String?, variantId: kotlin.String?, pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, attributeGroupId: kotlin.String?, setName: kotlin.String?, langId: kotlin.String?, storeId: kotlin.String?, sortBy: kotlin.String?, sortDirection: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseProductAttributeList?> {
        val localVariableConfig = productAttributeListRequestConfig(productId = productId, attributeId = attributeId, variantId = variantId, pageCursor = pageCursor, start = start, count = count, attributeGroupId = attributeGroupId, setName = setName, langId = langId, storeId = storeId, sortBy = sortBy, sortDirection = sortDirection, params = params, responseFields = responseFields, exclude = exclude)

        return request<Unit, ModelResponseProductAttributeList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productAttributeList
     *
     * @param productId Retrieves attributes specified by product id
     * @param attributeId Retrieves info for specified attribute_id (optional)
     * @param variantId Defines product&#39;s variants specified by variant id (optional)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param attributeGroupId Filter by attribute_group_id (optional)
     * @param setName Retrieves attributes specified by set_name in Magento (optional)
     * @param langId Retrieves attributes specified by language id (optional)
     * @param storeId Retrieves attributes specified by store id (optional)
     * @param sortBy Set field to sort by (optional, default to "attribute_id")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "attribute_id,name")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun productAttributeListRequestConfig(productId: kotlin.String, attributeId: kotlin.String?, variantId: kotlin.String?, pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, attributeGroupId: kotlin.String?, setName: kotlin.String?, langId: kotlin.String?, storeId: kotlin.String?, sortBy: kotlin.String?, sortDirection: kotlin.String?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                if (attributeId != null) {
                    put("attribute_id", listOf(attributeId.toString()))
                }
                if (variantId != null) {
                    put("variant_id", listOf(variantId.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (attributeGroupId != null) {
                    put("attribute_group_id", listOf(attributeGroupId.toString()))
                }
                if (setName != null) {
                    put("set_name", listOf(setName.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (sortBy != null) {
                    put("sort_by", listOf(sortBy.toString()))
                }
                if (sortDirection != null) {
                    put("sort_direction", listOf(sortDirection.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.attribute.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.attribute.value.set
     * Set attribute value to product.
     * @param productId Defines product id where the attribute should be added
     * @param attributeId Filter by attribute_id (optional)
     * @param attributeGroupId Filter by attribute_group_id (optional)
     * @param attributeName Define attribute name (optional)
     * @param `value` Define attribute value (optional)
     * @param valueId Define attribute value id (optional)
     * @param langId Language id (optional)
     * @param storeId Store Id (optional)
     * @return ProductAttributeValueSet200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productAttributeValueSet(productId: kotlin.String, attributeId: kotlin.String? = null, attributeGroupId: kotlin.String? = null, attributeName: kotlin.String? = null, `value`: kotlin.String? = null, valueId: kotlin.Int? = null, langId: kotlin.String? = null, storeId: kotlin.String? = null) : ProductAttributeValueSet200Response {
        val localVarResponse = productAttributeValueSetWithHttpInfo(productId = productId, attributeId = attributeId, attributeGroupId = attributeGroupId, attributeName = attributeName, `value` = `value`, valueId = valueId, langId = langId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductAttributeValueSet200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.attribute.value.set
     * Set attribute value to product.
     * @param productId Defines product id where the attribute should be added
     * @param attributeId Filter by attribute_id (optional)
     * @param attributeGroupId Filter by attribute_group_id (optional)
     * @param attributeName Define attribute name (optional)
     * @param `value` Define attribute value (optional)
     * @param valueId Define attribute value id (optional)
     * @param langId Language id (optional)
     * @param storeId Store Id (optional)
     * @return ApiResponse<ProductAttributeValueSet200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productAttributeValueSetWithHttpInfo(productId: kotlin.String, attributeId: kotlin.String?, attributeGroupId: kotlin.String?, attributeName: kotlin.String?, `value`: kotlin.String?, valueId: kotlin.Int?, langId: kotlin.String?, storeId: kotlin.String?) : ApiResponse<ProductAttributeValueSet200Response?> {
        val localVariableConfig = productAttributeValueSetRequestConfig(productId = productId, attributeId = attributeId, attributeGroupId = attributeGroupId, attributeName = attributeName, `value` = `value`, valueId = valueId, langId = langId, storeId = storeId)

        return request<Unit, ProductAttributeValueSet200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productAttributeValueSet
     *
     * @param productId Defines product id where the attribute should be added
     * @param attributeId Filter by attribute_id (optional)
     * @param attributeGroupId Filter by attribute_group_id (optional)
     * @param attributeName Define attribute name (optional)
     * @param `value` Define attribute value (optional)
     * @param valueId Define attribute value id (optional)
     * @param langId Language id (optional)
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productAttributeValueSetRequestConfig(productId: kotlin.String, attributeId: kotlin.String?, attributeGroupId: kotlin.String?, attributeName: kotlin.String?, `value`: kotlin.String?, valueId: kotlin.Int?, langId: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                if (attributeId != null) {
                    put("attribute_id", listOf(attributeId.toString()))
                }
                if (attributeGroupId != null) {
                    put("attribute_group_id", listOf(attributeGroupId.toString()))
                }
                if (attributeName != null) {
                    put("attribute_name", listOf(attributeName.toString()))
                }
                if (`value` != null) {
                    put("value", listOf(`value`.toString()))
                }
                if (valueId != null) {
                    put("value_id", listOf(valueId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.attribute.value.set.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.attribute.value.unset
     * Removes attribute value for a product.
     * @param productId Product id
     * @param attributeId Attribute Id
     * @param storeId Store Id (optional)
     * @param includeDefault Boolean, whether or not to unset default value of the attribute, if applicable (optional, default to false)
     * @param reindex Is reindex required (optional, default to true)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return ProductAttributeValueUnset200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productAttributeValueUnset(productId: kotlin.String, attributeId: kotlin.String, storeId: kotlin.String? = null, includeDefault: kotlin.Boolean? = false, reindex: kotlin.Boolean? = true, clearCache: kotlin.Boolean? = true) : ProductAttributeValueUnset200Response {
        val localVarResponse = productAttributeValueUnsetWithHttpInfo(productId = productId, attributeId = attributeId, storeId = storeId, includeDefault = includeDefault, reindex = reindex, clearCache = clearCache)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductAttributeValueUnset200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.attribute.value.unset
     * Removes attribute value for a product.
     * @param productId Product id
     * @param attributeId Attribute Id
     * @param storeId Store Id (optional)
     * @param includeDefault Boolean, whether or not to unset default value of the attribute, if applicable (optional, default to false)
     * @param reindex Is reindex required (optional, default to true)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return ApiResponse<ProductAttributeValueUnset200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productAttributeValueUnsetWithHttpInfo(productId: kotlin.String, attributeId: kotlin.String, storeId: kotlin.String?, includeDefault: kotlin.Boolean?, reindex: kotlin.Boolean?, clearCache: kotlin.Boolean?) : ApiResponse<ProductAttributeValueUnset200Response?> {
        val localVariableConfig = productAttributeValueUnsetRequestConfig(productId = productId, attributeId = attributeId, storeId = storeId, includeDefault = includeDefault, reindex = reindex, clearCache = clearCache)

        return request<Unit, ProductAttributeValueUnset200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productAttributeValueUnset
     *
     * @param productId Product id
     * @param attributeId Attribute Id
     * @param storeId Store Id (optional)
     * @param includeDefault Boolean, whether or not to unset default value of the attribute, if applicable (optional, default to false)
     * @param reindex Is reindex required (optional, default to true)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return RequestConfig
     */
    fun productAttributeValueUnsetRequestConfig(productId: kotlin.String, attributeId: kotlin.String, storeId: kotlin.String?, includeDefault: kotlin.Boolean?, reindex: kotlin.Boolean?, clearCache: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                put("attribute_id", listOf(attributeId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (includeDefault != null) {
                    put("include_default", listOf(includeDefault.toString()))
                }
                if (reindex != null) {
                    put("reindex", listOf(reindex.toString()))
                }
                if (clearCache != null) {
                    put("clear_cache", listOf(clearCache.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.attribute.value.unset.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.brand.list
     * Get list of brands from your store.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,short_description,active,url")
     * @param brandIds Retrieves brands specified by brand ids (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param parentId Retrieves brands specified by parent id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @return ModelResponseProductBrandList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productBrandList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, params: kotlin.String? = "id,name,short_description,active,url", brandIds: kotlin.String? = null, exclude: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, parentId: kotlin.String? = null, responseFields: kotlin.String? = null, findWhere: kotlin.String? = null, findValue: kotlin.String? = null) : ModelResponseProductBrandList {
        val localVarResponse = productBrandListWithHttpInfo(start = start, count = count, pageCursor = pageCursor, params = params, brandIds = brandIds, exclude = exclude, storeId = storeId, langId = langId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, parentId = parentId, responseFields = responseFields, findWhere = findWhere, findValue = findValue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseProductBrandList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.brand.list
     * Get list of brands from your store.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,short_description,active,url")
     * @param brandIds Retrieves brands specified by brand ids (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param parentId Retrieves brands specified by parent id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @return ApiResponse<ModelResponseProductBrandList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productBrandListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, params: kotlin.String?, brandIds: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, parentId: kotlin.String?, responseFields: kotlin.String?, findWhere: kotlin.String?, findValue: kotlin.String?) : ApiResponse<ModelResponseProductBrandList?> {
        val localVariableConfig = productBrandListRequestConfig(start = start, count = count, pageCursor = pageCursor, params = params, brandIds = brandIds, exclude = exclude, storeId = storeId, langId = langId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, parentId = parentId, responseFields = responseFields, findWhere = findWhere, findValue = findValue)

        return request<Unit, ModelResponseProductBrandList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productBrandList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,short_description,active,url")
     * @param brandIds Retrieves brands specified by brand ids (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param parentId Retrieves brands specified by parent id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @return RequestConfig
     */
    fun productBrandListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, params: kotlin.String?, brandIds: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, parentId: kotlin.String?, responseFields: kotlin.String?, findWhere: kotlin.String?, findValue: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (brandIds != null) {
                    put("brand_ids", listOf(brandIds.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (parentId != null) {
                    put("parent_id", listOf(parentId.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (findValue != null) {
                    put("find_value", listOf(findValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.brand.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.child_item.find
     * Search product child item (bundled item or configurable product variant) in store catalog.
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional)
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param storeId Store Id (optional)
     * @return ProductChildItemFind200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productChildItemFind(findValue: kotlin.String? = null, findWhere: kotlin.String? = null, findParams: kotlin.String? = "whole_words", storeId: kotlin.String? = null) : ProductChildItemFind200Response {
        val localVarResponse = productChildItemFindWithHttpInfo(findValue = findValue, findWhere = findWhere, findParams = findParams, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductChildItemFind200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.child_item.find
     * Search product child item (bundled item or configurable product variant) in store catalog.
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional)
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param storeId Store Id (optional)
     * @return ApiResponse<ProductChildItemFind200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productChildItemFindWithHttpInfo(findValue: kotlin.String?, findWhere: kotlin.String?, findParams: kotlin.String?, storeId: kotlin.String?) : ApiResponse<ProductChildItemFind200Response?> {
        val localVariableConfig = productChildItemFindRequestConfig(findValue = findValue, findWhere = findWhere, findParams = findParams, storeId = storeId)

        return request<Unit, ProductChildItemFind200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productChildItemFind
     *
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional)
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productChildItemFindRequestConfig(findValue: kotlin.String?, findWhere: kotlin.String?, findParams: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (findValue != null) {
                    put("find_value", listOf(findValue.toString()))
                }
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (findParams != null) {
                    put("find_params", listOf(findParams.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.child_item.find.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.child_item.info
     * Get child for specific product.
     * @param productId Filter by parent product id
     * @param id Entity id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param currencyId Currency Id (optional)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @return ProductChildItemInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productChildItemInfo(productId: kotlin.String, id: kotlin.String, params: kotlin.String? = "force_all", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, currencyId: kotlin.String? = null, useLatestApiVersion: kotlin.Boolean? = false) : ProductChildItemInfo200Response {
        val localVarResponse = productChildItemInfoWithHttpInfo(productId = productId, id = id, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId, langId = langId, currencyId = currencyId, useLatestApiVersion = useLatestApiVersion)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductChildItemInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.child_item.info
     * Get child for specific product.
     * @param productId Filter by parent product id
     * @param id Entity id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param currencyId Currency Id (optional)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @return ApiResponse<ProductChildItemInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productChildItemInfoWithHttpInfo(productId: kotlin.String, id: kotlin.String, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, currencyId: kotlin.String?, useLatestApiVersion: kotlin.Boolean?) : ApiResponse<ProductChildItemInfo200Response?> {
        val localVariableConfig = productChildItemInfoRequestConfig(productId = productId, id = id, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId, langId = langId, currencyId = currencyId, useLatestApiVersion = useLatestApiVersion)

        return request<Unit, ProductChildItemInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productChildItemInfo
     *
     * @param productId Filter by parent product id
     * @param id Entity id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param currencyId Currency Id (optional)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @return RequestConfig
     */
    fun productChildItemInfoRequestConfig(productId: kotlin.String, id: kotlin.String, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, currencyId: kotlin.String?, useLatestApiVersion: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                put("product_id", listOf(productId.toString()))
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (currencyId != null) {
                    put("currency_id", listOf(currencyId.toString()))
                }
                if (useLatestApiVersion != null) {
                    put("use_latest_api_version", listOf(useLatestApiVersion.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.child_item.info.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.child_item.list
     * Get a list of a product&#39;s child items, such as variants or bundle components. The total_count field in the response indicates the total number of items in the context of the current filter.
     * @param pageCursor Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param productId Filter by parent product id (optional)
     * @param productIds Filter by parent product ids (optional)
     * @param sku Filter by products variant&#39;s sku (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param currencyId Currency Id (optional)
     * @param availSale Specifies the set of available/not available products for sale (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Child products search that is specified by field (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param returnGlobal Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @return ModelResponseProductChildItemList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productChildItemList(pageCursor: kotlin.String? = null, start: kotlin.Int? = 0, count: kotlin.Int? = 10, params: kotlin.String? = "force_all", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, productId: kotlin.String? = null, productIds: kotlin.String? = null, sku: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, currencyId: kotlin.String? = null, availSale: kotlin.Boolean? = null, findValue: kotlin.String? = null, findWhere: kotlin.String? = null, reportRequestId: kotlin.String? = null, disableReportCache: kotlin.Boolean? = false, useLatestApiVersion: kotlin.Boolean? = false, returnGlobal: kotlin.Boolean? = false) : ModelResponseProductChildItemList {
        val localVarResponse = productChildItemListWithHttpInfo(pageCursor = pageCursor, start = start, count = count, params = params, responseFields = responseFields, exclude = exclude, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, productId = productId, productIds = productIds, sku = sku, storeId = storeId, langId = langId, currencyId = currencyId, availSale = availSale, findValue = findValue, findWhere = findWhere, reportRequestId = reportRequestId, disableReportCache = disableReportCache, useLatestApiVersion = useLatestApiVersion, returnGlobal = returnGlobal)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseProductChildItemList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.child_item.list
     * Get a list of a product&#39;s child items, such as variants or bundle components. The total_count field in the response indicates the total number of items in the context of the current filter.
     * @param pageCursor Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param productId Filter by parent product id (optional)
     * @param productIds Filter by parent product ids (optional)
     * @param sku Filter by products variant&#39;s sku (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param currencyId Currency Id (optional)
     * @param availSale Specifies the set of available/not available products for sale (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Child products search that is specified by field (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param returnGlobal Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @return ApiResponse<ModelResponseProductChildItemList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productChildItemListWithHttpInfo(pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, productId: kotlin.String?, productIds: kotlin.String?, sku: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, currencyId: kotlin.String?, availSale: kotlin.Boolean?, findValue: kotlin.String?, findWhere: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, useLatestApiVersion: kotlin.Boolean?, returnGlobal: kotlin.Boolean?) : ApiResponse<ModelResponseProductChildItemList?> {
        val localVariableConfig = productChildItemListRequestConfig(pageCursor = pageCursor, start = start, count = count, params = params, responseFields = responseFields, exclude = exclude, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, productId = productId, productIds = productIds, sku = sku, storeId = storeId, langId = langId, currencyId = currencyId, availSale = availSale, findValue = findValue, findWhere = findWhere, reportRequestId = reportRequestId, disableReportCache = disableReportCache, useLatestApiVersion = useLatestApiVersion, returnGlobal = returnGlobal)

        return request<Unit, ModelResponseProductChildItemList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productChildItemList
     *
     * @param pageCursor Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "force_all")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param productId Filter by parent product id (optional)
     * @param productIds Filter by parent product ids (optional)
     * @param sku Filter by products variant&#39;s sku (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param currencyId Currency Id (optional)
     * @param availSale Specifies the set of available/not available products for sale (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Child products search that is specified by field (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param returnGlobal Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @return RequestConfig
     */
    fun productChildItemListRequestConfig(pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, productId: kotlin.String?, productIds: kotlin.String?, sku: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, currencyId: kotlin.String?, availSale: kotlin.Boolean?, findValue: kotlin.String?, findWhere: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, useLatestApiVersion: kotlin.Boolean?, returnGlobal: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (productId != null) {
                    put("product_id", listOf(productId.toString()))
                }
                if (productIds != null) {
                    put("product_ids", listOf(productIds.toString()))
                }
                if (sku != null) {
                    put("sku", listOf(sku.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (currencyId != null) {
                    put("currency_id", listOf(currencyId.toString()))
                }
                if (availSale != null) {
                    put("avail_sale", listOf(availSale.toString()))
                }
                if (findValue != null) {
                    put("find_value", listOf(findValue.toString()))
                }
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (reportRequestId != null) {
                    put("report_request_id", listOf(reportRequestId.toString()))
                }
                if (disableReportCache != null) {
                    put("disable_report_cache", listOf(disableReportCache.toString()))
                }
                if (useLatestApiVersion != null) {
                    put("use_latest_api_version", listOf(useLatestApiVersion.toString()))
                }
                if (returnGlobal != null) {
                    put("return_global", listOf(returnGlobal.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.child_item.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.count
     * Count products in store.
     * @param categoryId Counts products specified by category id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param availView Specifies the set of visible/invisible products (optional)
     * @param availSale Specifies the set of available/not available products for sale (optional)
     * @param storeId Counts products specified by store id (optional)
     * @param langId Counts products specified by language id (optional)
     * @param productIds Counts products specified by product ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param brandName Retrieves brands specified by brand name (optional)
     * @param productAttributes Defines product attributes (optional)
     * @param status Defines product&#39;s status (optional)
     * @param type Defines products&#39;s type (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Counts products that are searched specified by field (optional)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param returnGlobal Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param categoriesIds Defines product add that is specified by comma-separated categories id (optional)
     * @return ProductCount200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productCount(categoryId: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, availView: kotlin.Boolean? = null, availSale: kotlin.Boolean? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, productIds: kotlin.String? = null, sinceId: kotlin.String? = null, reportRequestId: kotlin.String? = null, disableReportCache: kotlin.Boolean? = false, brandName: kotlin.String? = null, productAttributes: kotlin.collections.List<kotlin.String>? = null, status: kotlin.String? = null, type: kotlin.String? = null, findValue: kotlin.String? = null, findWhere: kotlin.String? = null, useLatestApiVersion: kotlin.Boolean? = false, returnGlobal: kotlin.Boolean? = false, categoriesIds: kotlin.String? = null) : ProductCount200Response {
        val localVarResponse = productCountWithHttpInfo(categoryId = categoryId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, availView = availView, availSale = availSale, storeId = storeId, langId = langId, productIds = productIds, sinceId = sinceId, reportRequestId = reportRequestId, disableReportCache = disableReportCache, brandName = brandName, productAttributes = productAttributes, status = status, type = type, findValue = findValue, findWhere = findWhere, useLatestApiVersion = useLatestApiVersion, returnGlobal = returnGlobal, categoriesIds = categoriesIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductCount200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.count
     * Count products in store.
     * @param categoryId Counts products specified by category id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param availView Specifies the set of visible/invisible products (optional)
     * @param availSale Specifies the set of available/not available products for sale (optional)
     * @param storeId Counts products specified by store id (optional)
     * @param langId Counts products specified by language id (optional)
     * @param productIds Counts products specified by product ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param brandName Retrieves brands specified by brand name (optional)
     * @param productAttributes Defines product attributes (optional)
     * @param status Defines product&#39;s status (optional)
     * @param type Defines products&#39;s type (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Counts products that are searched specified by field (optional)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param returnGlobal Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param categoriesIds Defines product add that is specified by comma-separated categories id (optional)
     * @return ApiResponse<ProductCount200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productCountWithHttpInfo(categoryId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, availView: kotlin.Boolean?, availSale: kotlin.Boolean?, storeId: kotlin.String?, langId: kotlin.String?, productIds: kotlin.String?, sinceId: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, brandName: kotlin.String?, productAttributes: kotlin.collections.List<kotlin.String>?, status: kotlin.String?, type: kotlin.String?, findValue: kotlin.String?, findWhere: kotlin.String?, useLatestApiVersion: kotlin.Boolean?, returnGlobal: kotlin.Boolean?, categoriesIds: kotlin.String?) : ApiResponse<ProductCount200Response?> {
        val localVariableConfig = productCountRequestConfig(categoryId = categoryId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, availView = availView, availSale = availSale, storeId = storeId, langId = langId, productIds = productIds, sinceId = sinceId, reportRequestId = reportRequestId, disableReportCache = disableReportCache, brandName = brandName, productAttributes = productAttributes, status = status, type = type, findValue = findValue, findWhere = findWhere, useLatestApiVersion = useLatestApiVersion, returnGlobal = returnGlobal, categoriesIds = categoriesIds)

        return request<Unit, ProductCount200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productCount
     *
     * @param categoryId Counts products specified by category id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param availView Specifies the set of visible/invisible products (optional)
     * @param availSale Specifies the set of available/not available products for sale (optional)
     * @param storeId Counts products specified by store id (optional)
     * @param langId Counts products specified by language id (optional)
     * @param productIds Counts products specified by product ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param brandName Retrieves brands specified by brand name (optional)
     * @param productAttributes Defines product attributes (optional)
     * @param status Defines product&#39;s status (optional)
     * @param type Defines products&#39;s type (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Counts products that are searched specified by field (optional)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param returnGlobal Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param categoriesIds Defines product add that is specified by comma-separated categories id (optional)
     * @return RequestConfig
     */
    fun productCountRequestConfig(categoryId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, availView: kotlin.Boolean?, availSale: kotlin.Boolean?, storeId: kotlin.String?, langId: kotlin.String?, productIds: kotlin.String?, sinceId: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, brandName: kotlin.String?, productAttributes: kotlin.collections.List<kotlin.String>?, status: kotlin.String?, type: kotlin.String?, findValue: kotlin.String?, findWhere: kotlin.String?, useLatestApiVersion: kotlin.Boolean?, returnGlobal: kotlin.Boolean?, categoriesIds: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (categoryId != null) {
                    put("category_id", listOf(categoryId.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (availView != null) {
                    put("avail_view", listOf(availView.toString()))
                }
                if (availSale != null) {
                    put("avail_sale", listOf(availSale.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (productIds != null) {
                    put("product_ids", listOf(productIds.toString()))
                }
                if (sinceId != null) {
                    put("since_id", listOf(sinceId.toString()))
                }
                if (reportRequestId != null) {
                    put("report_request_id", listOf(reportRequestId.toString()))
                }
                if (disableReportCache != null) {
                    put("disable_report_cache", listOf(disableReportCache.toString()))
                }
                if (brandName != null) {
                    put("brand_name", listOf(brandName.toString()))
                }
                if (productAttributes != null) {
                    put("product_attributes", toMultiValue(productAttributes.toList(), "multi"))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (findValue != null) {
                    put("find_value", listOf(findValue.toString()))
                }
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (useLatestApiVersion != null) {
                    put("use_latest_api_version", listOf(useLatestApiVersion.toString()))
                }
                if (returnGlobal != null) {
                    put("return_global", listOf(returnGlobal.toString()))
                }
                if (categoriesIds != null) {
                    put("categories_ids", listOf(categoriesIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.count.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.currency.add
     * Add currency and/or set default in store
     * @param iso3 Specifies standardized currency code
     * @param rate Defines the numerical identifier against to the major currency
     * @param name Defines currency&#39;s name (optional)
     * @param avail Specifies whether the currency is available (optional, default to true)
     * @param symbolLeft Defines the symbol that is located before the currency (optional)
     * @param symbolRight Defines the symbol that is located after the currency (optional)
     * @param default Specifies currency&#39;s default meaning (optional, default to false)
     * @return ProductCurrencyAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productCurrencyAdd(iso3: kotlin.String, rate: java.math.BigDecimal, name: kotlin.String? = null, avail: kotlin.Boolean? = true, symbolLeft: kotlin.String? = null, symbolRight: kotlin.String? = null, default: kotlin.Boolean? = false) : ProductCurrencyAdd200Response {
        val localVarResponse = productCurrencyAddWithHttpInfo(iso3 = iso3, rate = rate, name = name, avail = avail, symbolLeft = symbolLeft, symbolRight = symbolRight, default = default)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductCurrencyAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.currency.add
     * Add currency and/or set default in store
     * @param iso3 Specifies standardized currency code
     * @param rate Defines the numerical identifier against to the major currency
     * @param name Defines currency&#39;s name (optional)
     * @param avail Specifies whether the currency is available (optional, default to true)
     * @param symbolLeft Defines the symbol that is located before the currency (optional)
     * @param symbolRight Defines the symbol that is located after the currency (optional)
     * @param default Specifies currency&#39;s default meaning (optional, default to false)
     * @return ApiResponse<ProductCurrencyAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productCurrencyAddWithHttpInfo(iso3: kotlin.String, rate: java.math.BigDecimal, name: kotlin.String?, avail: kotlin.Boolean?, symbolLeft: kotlin.String?, symbolRight: kotlin.String?, default: kotlin.Boolean?) : ApiResponse<ProductCurrencyAdd200Response?> {
        val localVariableConfig = productCurrencyAddRequestConfig(iso3 = iso3, rate = rate, name = name, avail = avail, symbolLeft = symbolLeft, symbolRight = symbolRight, default = default)

        return request<Unit, ProductCurrencyAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productCurrencyAdd
     *
     * @param iso3 Specifies standardized currency code
     * @param rate Defines the numerical identifier against to the major currency
     * @param name Defines currency&#39;s name (optional)
     * @param avail Specifies whether the currency is available (optional, default to true)
     * @param symbolLeft Defines the symbol that is located before the currency (optional)
     * @param symbolRight Defines the symbol that is located after the currency (optional)
     * @param default Specifies currency&#39;s default meaning (optional, default to false)
     * @return RequestConfig
     */
    fun productCurrencyAddRequestConfig(iso3: kotlin.String, rate: java.math.BigDecimal, name: kotlin.String?, avail: kotlin.Boolean?, symbolLeft: kotlin.String?, symbolRight: kotlin.String?, default: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("iso3", listOf(iso3.toString()))
                put("rate", listOf(rate.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
                if (symbolLeft != null) {
                    put("symbol_left", listOf(symbolLeft.toString()))
                }
                if (symbolRight != null) {
                    put("symbol_right", listOf(symbolRight.toString()))
                }
                if (default != null) {
                    put("default", listOf(default.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.currency.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.currency.list
     * Get list of currencies
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "name,iso3,default,avail")
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param default Specifies the set of default/not default currencies (optional)
     * @param avail Specifies the set of available/not available currencies (optional)
     * @return ModelResponseProductCurrencyList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productCurrencyList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, params: kotlin.String? = "name,iso3,default,avail", pageCursor: kotlin.String? = null, exclude: kotlin.String? = null, responseFields: kotlin.String? = null, default: kotlin.Boolean? = null, avail: kotlin.Boolean? = null) : ModelResponseProductCurrencyList {
        val localVarResponse = productCurrencyListWithHttpInfo(start = start, count = count, params = params, pageCursor = pageCursor, exclude = exclude, responseFields = responseFields, default = default, avail = avail)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseProductCurrencyList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.currency.list
     * Get list of currencies
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "name,iso3,default,avail")
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param default Specifies the set of default/not default currencies (optional)
     * @param avail Specifies the set of available/not available currencies (optional)
     * @return ApiResponse<ModelResponseProductCurrencyList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productCurrencyListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, pageCursor: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?, default: kotlin.Boolean?, avail: kotlin.Boolean?) : ApiResponse<ModelResponseProductCurrencyList?> {
        val localVariableConfig = productCurrencyListRequestConfig(start = start, count = count, params = params, pageCursor = pageCursor, exclude = exclude, responseFields = responseFields, default = default, avail = avail)

        return request<Unit, ModelResponseProductCurrencyList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productCurrencyList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "name,iso3,default,avail")
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param default Specifies the set of default/not default currencies (optional)
     * @param avail Specifies the set of available/not available currencies (optional)
     * @return RequestConfig
     */
    fun productCurrencyListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, pageCursor: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?, default: kotlin.Boolean?, avail: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (default != null) {
                    put("default", listOf(default.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.currency.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.delete
     * Product delete
     * @param id Product id that will be removed
     * @param storeId Store Id (optional)
     * @return CustomerDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productDelete(id: kotlin.String, storeId: kotlin.String? = null) : CustomerDelete200Response {
        val localVarResponse = productDeleteWithHttpInfo(id = id, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.delete
     * Product delete
     * @param id Product id that will be removed
     * @param storeId Store Id (optional)
     * @return ApiResponse<CustomerDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productDeleteWithHttpInfo(id: kotlin.String, storeId: kotlin.String?) : ApiResponse<CustomerDelete200Response?> {
        val localVariableConfig = productDeleteRequestConfig(id = id, storeId = storeId)

        return request<Unit, CustomerDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productDelete
     *
     * @param id Product id that will be removed
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productDeleteRequestConfig(id: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/product.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.delete.batch
     * Remove product from the store.
     * @param productDeleteBatch 
     * @return CategoryAddBatch200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productDeleteBatch(productDeleteBatch: ProductDeleteBatch) : CategoryAddBatch200Response {
        val localVarResponse = productDeleteBatchWithHttpInfo(productDeleteBatch = productDeleteBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryAddBatch200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.delete.batch
     * Remove product from the store.
     * @param productDeleteBatch 
     * @return ApiResponse<CategoryAddBatch200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productDeleteBatchWithHttpInfo(productDeleteBatch: ProductDeleteBatch) : ApiResponse<CategoryAddBatch200Response?> {
        val localVariableConfig = productDeleteBatchRequestConfig(productDeleteBatch = productDeleteBatch)

        return request<ProductDeleteBatch, CategoryAddBatch200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productDeleteBatch
     *
     * @param productDeleteBatch 
     * @return RequestConfig
     */
    fun productDeleteBatchRequestConfig(productDeleteBatch: ProductDeleteBatch) : RequestConfig<ProductDeleteBatch> {
        val localVariableBody = productDeleteBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.delete.batch.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.fields
     * Retrieve all available fields for product item in store.
     * @return CartConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun productFields() : CartConfigUpdate200Response {
        @Suppress("DEPRECATION")
        val localVarResponse = productFieldsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.fields
     * Retrieve all available fields for product item in store.
     * @return ApiResponse<CartConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun productFieldsWithHttpInfo() : ApiResponse<CartConfigUpdate200Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = productFieldsRequestConfig()

        return request<Unit, CartConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productFields
     *
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun productFieldsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.fields.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.find
     * Search product in store catalog. \&quot;Apple\&quot; is specified here by default.
     * @param findValue Entity search that is specified by some value
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional, default to "name")
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param findWhat Parameter&#39;s value specifies the entity that has to be found (optional, default to "product")
     * @param langId Search products specified by language id (optional)
     * @param storeId Store Id (optional)
     * @return ProductFind200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productFind(findValue: kotlin.String, findWhere: kotlin.String? = "name", findParams: kotlin.String? = "whole_words", findWhat: kotlin.String? = "product", langId: kotlin.String? = null, storeId: kotlin.String? = null) : ProductFind200Response {
        val localVarResponse = productFindWithHttpInfo(findValue = findValue, findWhere = findWhere, findParams = findParams, findWhat = findWhat, langId = langId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductFind200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.find
     * Search product in store catalog. \&quot;Apple\&quot; is specified here by default.
     * @param findValue Entity search that is specified by some value
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional, default to "name")
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param findWhat Parameter&#39;s value specifies the entity that has to be found (optional, default to "product")
     * @param langId Search products specified by language id (optional)
     * @param storeId Store Id (optional)
     * @return ApiResponse<ProductFind200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productFindWithHttpInfo(findValue: kotlin.String, findWhere: kotlin.String?, findParams: kotlin.String?, findWhat: kotlin.String?, langId: kotlin.String?, storeId: kotlin.String?) : ApiResponse<ProductFind200Response?> {
        val localVariableConfig = productFindRequestConfig(findValue = findValue, findWhere = findWhere, findParams = findParams, findWhat = findWhat, langId = langId, storeId = storeId)

        return request<Unit, ProductFind200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productFind
     *
     * @param findValue Entity search that is specified by some value
     * @param findWhere Entity search that is specified by the comma-separated unique fields (optional, default to "name")
     * @param findParams Entity search that is specified by comma-separated parameters (optional, default to "whole_words")
     * @param findWhat Parameter&#39;s value specifies the entity that has to be found (optional, default to "product")
     * @param langId Search products specified by language id (optional)
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productFindRequestConfig(findValue: kotlin.String, findWhere: kotlin.String?, findParams: kotlin.String?, findWhat: kotlin.String?, langId: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("find_value", listOf(findValue.toString()))
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (findParams != null) {
                    put("find_params", listOf(findParams.toString()))
                }
                if (findWhat != null) {
                    put("find_what", listOf(findWhat.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.find.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.image.add
     * Add image to product
     * @param productImageAdd 
     * @return ProductImageAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productImageAdd(productImageAdd: ProductImageAdd) : ProductImageAdd200Response {
        val localVarResponse = productImageAddWithHttpInfo(productImageAdd = productImageAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductImageAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.image.add
     * Add image to product
     * @param productImageAdd 
     * @return ApiResponse<ProductImageAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productImageAddWithHttpInfo(productImageAdd: ProductImageAdd) : ApiResponse<ProductImageAdd200Response?> {
        val localVariableConfig = productImageAddRequestConfig(productImageAdd = productImageAdd)

        return request<ProductImageAdd, ProductImageAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productImageAdd
     *
     * @param productImageAdd 
     * @return RequestConfig
     */
    fun productImageAddRequestConfig(productImageAdd: ProductImageAdd) : RequestConfig<ProductImageAdd> {
        val localVariableBody = productImageAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.image.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.image.delete
     * Delete image
     * @param productId Defines product id where the image should be deleted
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productImageDelete(productId: kotlin.String, id: kotlin.String, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = productImageDeleteWithHttpInfo(productId = productId, id = id, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.image.delete
     * Delete image
     * @param productId Defines product id where the image should be deleted
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productImageDeleteWithHttpInfo(productId: kotlin.String, id: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = productImageDeleteRequestConfig(productId = productId, id = id, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productImageDelete
     *
     * @param productId Defines product id where the image should be deleted
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productImageDeleteRequestConfig(productId: kotlin.String, id: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/product.image.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.image.update
     * Update details of image
     * @param productId Defines product id where the image should be updated
     * @param id Defines image update specified by image id
     * @param variantIds Defines product&#39;s variants ids (optional)
     * @param imageName Defines image&#39;s name (optional)
     * @param type Defines image&#39;s types that are specified by comma-separated list (optional, default to "additional")
     * @param label Defines alternative text that has to be attached to the picture (optional)
     * @param position Defines image’s position in the list (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param hidden Define is hide image (optional)
     * @return ProductImageUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productImageUpdate(productId: kotlin.String, id: kotlin.String, variantIds: kotlin.String? = null, imageName: kotlin.String? = null, type: kotlin.String? = "additional", label: kotlin.String? = null, position: kotlin.Int? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, hidden: kotlin.Boolean? = null) : ProductImageUpdate200Response {
        val localVarResponse = productImageUpdateWithHttpInfo(productId = productId, id = id, variantIds = variantIds, imageName = imageName, type = type, label = label, position = position, storeId = storeId, langId = langId, hidden = hidden)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductImageUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.image.update
     * Update details of image
     * @param productId Defines product id where the image should be updated
     * @param id Defines image update specified by image id
     * @param variantIds Defines product&#39;s variants ids (optional)
     * @param imageName Defines image&#39;s name (optional)
     * @param type Defines image&#39;s types that are specified by comma-separated list (optional, default to "additional")
     * @param label Defines alternative text that has to be attached to the picture (optional)
     * @param position Defines image’s position in the list (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param hidden Define is hide image (optional)
     * @return ApiResponse<ProductImageUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productImageUpdateWithHttpInfo(productId: kotlin.String, id: kotlin.String, variantIds: kotlin.String?, imageName: kotlin.String?, type: kotlin.String?, label: kotlin.String?, position: kotlin.Int?, storeId: kotlin.String?, langId: kotlin.String?, hidden: kotlin.Boolean?) : ApiResponse<ProductImageUpdate200Response?> {
        val localVariableConfig = productImageUpdateRequestConfig(productId = productId, id = id, variantIds = variantIds, imageName = imageName, type = type, label = label, position = position, storeId = storeId, langId = langId, hidden = hidden)

        return request<Unit, ProductImageUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productImageUpdate
     *
     * @param productId Defines product id where the image should be updated
     * @param id Defines image update specified by image id
     * @param variantIds Defines product&#39;s variants ids (optional)
     * @param imageName Defines image&#39;s name (optional)
     * @param type Defines image&#39;s types that are specified by comma-separated list (optional, default to "additional")
     * @param label Defines alternative text that has to be attached to the picture (optional)
     * @param position Defines image’s position in the list (optional)
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param hidden Define is hide image (optional)
     * @return RequestConfig
     */
    fun productImageUpdateRequestConfig(productId: kotlin.String, id: kotlin.String, variantIds: kotlin.String?, imageName: kotlin.String?, type: kotlin.String?, label: kotlin.String?, position: kotlin.Int?, storeId: kotlin.String?, langId: kotlin.String?, hidden: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                if (variantIds != null) {
                    put("variant_ids", listOf(variantIds.toString()))
                }
                if (imageName != null) {
                    put("image_name", listOf(imageName.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (label != null) {
                    put("label", listOf(label.toString()))
                }
                if (position != null) {
                    put("position", listOf(position.toString()))
                }
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (hidden != null) {
                    put("hidden", listOf(hidden.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/product.image.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.info
     * Get information about a specific product by its ID. In the case of a multistore configuration, use the store_id filter to get a response in the context of a specific store.
     * @param id Retrieves product&#39;s info specified by product id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price,categories_ids")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves product info specified by store id (optional)
     * @param langId Retrieves product info specified by language id (optional)
     * @param currencyId Currency Id (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @return ProductInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productInfo(id: kotlin.String, params: kotlin.String? = "id,name,description,price,categories_ids", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, currencyId: kotlin.String? = null, reportRequestId: kotlin.String? = null, disableReportCache: kotlin.Boolean? = false, useLatestApiVersion: kotlin.Boolean? = false) : ProductInfo200Response {
        val localVarResponse = productInfoWithHttpInfo(id = id, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId, langId = langId, currencyId = currencyId, reportRequestId = reportRequestId, disableReportCache = disableReportCache, useLatestApiVersion = useLatestApiVersion)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.info
     * Get information about a specific product by its ID. In the case of a multistore configuration, use the store_id filter to get a response in the context of a specific store.
     * @param id Retrieves product&#39;s info specified by product id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price,categories_ids")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves product info specified by store id (optional)
     * @param langId Retrieves product info specified by language id (optional)
     * @param currencyId Currency Id (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @return ApiResponse<ProductInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productInfoWithHttpInfo(id: kotlin.String, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, currencyId: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, useLatestApiVersion: kotlin.Boolean?) : ApiResponse<ProductInfo200Response?> {
        val localVariableConfig = productInfoRequestConfig(id = id, params = params, responseFields = responseFields, exclude = exclude, storeId = storeId, langId = langId, currencyId = currencyId, reportRequestId = reportRequestId, disableReportCache = disableReportCache, useLatestApiVersion = useLatestApiVersion)

        return request<Unit, ProductInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productInfo
     *
     * @param id Retrieves product&#39;s info specified by product id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price,categories_ids")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves product info specified by store id (optional)
     * @param langId Retrieves product info specified by language id (optional)
     * @param currencyId Currency Id (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @return RequestConfig
     */
    fun productInfoRequestConfig(id: kotlin.String, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, currencyId: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, useLatestApiVersion: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (currencyId != null) {
                    put("currency_id", listOf(currencyId.toString()))
                }
                if (reportRequestId != null) {
                    put("report_request_id", listOf(reportRequestId.toString()))
                }
                if (disableReportCache != null) {
                    put("disable_report_cache", listOf(disableReportCache.toString()))
                }
                if (useLatestApiVersion != null) {
                    put("use_latest_api_version", listOf(useLatestApiVersion.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.info.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.list
     * Get list of products from your store. Returns 10 products by default.
     * @param pageCursor Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price,categories_ids")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param categoryId Retrieves products specified by category id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param availView Specifies the set of visible/invisible products (optional)
     * @param availSale Specifies the set of available/not available products for sale (optional)
     * @param storeId Retrieves products specified by store id (optional)
     * @param langId Retrieves products specified by language id (optional)
     * @param currencyId Currency Id (optional)
     * @param productIds Retrieves products specified by product ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param sortBy Set field to sort by (optional, default to "id")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param sku Filter by product&#39;s sku (optional)
     * @param disableCache Disable cache for current request (optional, default to false)
     * @param brandName Retrieves brands specified by brand name (optional)
     * @param productAttributes Defines product attributes (optional)
     * @param status Defines product&#39;s status (optional)
     * @param type Defines products&#39;s type (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Product search that is specified by field (optional)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param returnGlobal Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param categoriesIds Retrieves products specified by categories ids (optional)
     * @return ModelResponseProductList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productList(pageCursor: kotlin.String? = null, start: kotlin.Int? = 0, count: kotlin.Int? = 10, params: kotlin.String? = "id,name,description,price,categories_ids", responseFields: kotlin.String? = null, exclude: kotlin.String? = null, categoryId: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, availView: kotlin.Boolean? = null, availSale: kotlin.Boolean? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, currencyId: kotlin.String? = null, productIds: kotlin.String? = null, sinceId: kotlin.String? = null, reportRequestId: kotlin.String? = null, disableReportCache: kotlin.Boolean? = false, sortBy: kotlin.String? = "id", sortDirection: kotlin.String? = "asc", sku: kotlin.String? = null, disableCache: kotlin.Boolean? = false, brandName: kotlin.String? = null, productAttributes: kotlin.collections.List<kotlin.String>? = null, status: kotlin.String? = null, type: kotlin.String? = null, findValue: kotlin.String? = null, findWhere: kotlin.String? = null, useLatestApiVersion: kotlin.Boolean? = false, returnGlobal: kotlin.Boolean? = false, categoriesIds: kotlin.String? = null) : ModelResponseProductList {
        val localVarResponse = productListWithHttpInfo(pageCursor = pageCursor, start = start, count = count, params = params, responseFields = responseFields, exclude = exclude, categoryId = categoryId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, availView = availView, availSale = availSale, storeId = storeId, langId = langId, currencyId = currencyId, productIds = productIds, sinceId = sinceId, reportRequestId = reportRequestId, disableReportCache = disableReportCache, sortBy = sortBy, sortDirection = sortDirection, sku = sku, disableCache = disableCache, brandName = brandName, productAttributes = productAttributes, status = status, type = type, findValue = findValue, findWhere = findWhere, useLatestApiVersion = useLatestApiVersion, returnGlobal = returnGlobal, categoriesIds = categoriesIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseProductList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.list
     * Get list of products from your store. Returns 10 products by default.
     * @param pageCursor Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price,categories_ids")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param categoryId Retrieves products specified by category id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param availView Specifies the set of visible/invisible products (optional)
     * @param availSale Specifies the set of available/not available products for sale (optional)
     * @param storeId Retrieves products specified by store id (optional)
     * @param langId Retrieves products specified by language id (optional)
     * @param currencyId Currency Id (optional)
     * @param productIds Retrieves products specified by product ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param sortBy Set field to sort by (optional, default to "id")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param sku Filter by product&#39;s sku (optional)
     * @param disableCache Disable cache for current request (optional, default to false)
     * @param brandName Retrieves brands specified by brand name (optional)
     * @param productAttributes Defines product attributes (optional)
     * @param status Defines product&#39;s status (optional)
     * @param type Defines products&#39;s type (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Product search that is specified by field (optional)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param returnGlobal Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param categoriesIds Retrieves products specified by categories ids (optional)
     * @return ApiResponse<ModelResponseProductList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productListWithHttpInfo(pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, categoryId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, availView: kotlin.Boolean?, availSale: kotlin.Boolean?, storeId: kotlin.String?, langId: kotlin.String?, currencyId: kotlin.String?, productIds: kotlin.String?, sinceId: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, sortBy: kotlin.String?, sortDirection: kotlin.String?, sku: kotlin.String?, disableCache: kotlin.Boolean?, brandName: kotlin.String?, productAttributes: kotlin.collections.List<kotlin.String>?, status: kotlin.String?, type: kotlin.String?, findValue: kotlin.String?, findWhere: kotlin.String?, useLatestApiVersion: kotlin.Boolean?, returnGlobal: kotlin.Boolean?, categoriesIds: kotlin.String?) : ApiResponse<ModelResponseProductList?> {
        val localVariableConfig = productListRequestConfig(pageCursor = pageCursor, start = start, count = count, params = params, responseFields = responseFields, exclude = exclude, categoryId = categoryId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, availView = availView, availSale = availSale, storeId = storeId, langId = langId, currencyId = currencyId, productIds = productIds, sinceId = sinceId, reportRequestId = reportRequestId, disableReportCache = disableReportCache, sortBy = sortBy, sortDirection = sortDirection, sku = sku, disableCache = disableCache, brandName = brandName, productAttributes = productAttributes, status = status, type = type, findValue = findValue, findWhere = findWhere, useLatestApiVersion = useLatestApiVersion, returnGlobal = returnGlobal, categoriesIds = categoriesIds)

        return request<Unit, ModelResponseProductList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productList
     *
     * @param pageCursor Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price,categories_ids")
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param categoryId Retrieves products specified by category id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param availView Specifies the set of visible/invisible products (optional)
     * @param availSale Specifies the set of available/not available products for sale (optional)
     * @param storeId Retrieves products specified by store id (optional)
     * @param langId Retrieves products specified by language id (optional)
     * @param currencyId Currency Id (optional)
     * @param productIds Retrieves products specified by product ids (optional)
     * @param sinceId Retrieve entities starting from the specified id. (optional)
     * @param reportRequestId Report request id (optional)
     * @param disableReportCache Disable report cache for current request (optional, default to false)
     * @param sortBy Set field to sort by (optional, default to "id")
     * @param sortDirection Set sorting direction (optional, default to "asc")
     * @param sku Filter by product&#39;s sku (optional)
     * @param disableCache Disable cache for current request (optional, default to false)
     * @param brandName Retrieves brands specified by brand name (optional)
     * @param productAttributes Defines product attributes (optional)
     * @param status Defines product&#39;s status (optional)
     * @param type Defines products&#39;s type (optional)
     * @param findValue Entity search that is specified by some value (optional)
     * @param findWhere Product search that is specified by field (optional)
     * @param useLatestApiVersion Use the latest platform API version (optional, default to false)
     * @param returnGlobal Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param categoriesIds Retrieves products specified by categories ids (optional)
     * @return RequestConfig
     */
    fun productListRequestConfig(pageCursor: kotlin.String?, start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, responseFields: kotlin.String?, exclude: kotlin.String?, categoryId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, availView: kotlin.Boolean?, availSale: kotlin.Boolean?, storeId: kotlin.String?, langId: kotlin.String?, currencyId: kotlin.String?, productIds: kotlin.String?, sinceId: kotlin.String?, reportRequestId: kotlin.String?, disableReportCache: kotlin.Boolean?, sortBy: kotlin.String?, sortDirection: kotlin.String?, sku: kotlin.String?, disableCache: kotlin.Boolean?, brandName: kotlin.String?, productAttributes: kotlin.collections.List<kotlin.String>?, status: kotlin.String?, type: kotlin.String?, findValue: kotlin.String?, findWhere: kotlin.String?, useLatestApiVersion: kotlin.Boolean?, returnGlobal: kotlin.Boolean?, categoriesIds: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (categoryId != null) {
                    put("category_id", listOf(categoryId.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (availView != null) {
                    put("avail_view", listOf(availView.toString()))
                }
                if (availSale != null) {
                    put("avail_sale", listOf(availSale.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (currencyId != null) {
                    put("currency_id", listOf(currencyId.toString()))
                }
                if (productIds != null) {
                    put("product_ids", listOf(productIds.toString()))
                }
                if (sinceId != null) {
                    put("since_id", listOf(sinceId.toString()))
                }
                if (reportRequestId != null) {
                    put("report_request_id", listOf(reportRequestId.toString()))
                }
                if (disableReportCache != null) {
                    put("disable_report_cache", listOf(disableReportCache.toString()))
                }
                if (sortBy != null) {
                    put("sort_by", listOf(sortBy.toString()))
                }
                if (sortDirection != null) {
                    put("sort_direction", listOf(sortDirection.toString()))
                }
                if (sku != null) {
                    put("sku", listOf(sku.toString()))
                }
                if (disableCache != null) {
                    put("disable_cache", listOf(disableCache.toString()))
                }
                if (brandName != null) {
                    put("brand_name", listOf(brandName.toString()))
                }
                if (productAttributes != null) {
                    put("product_attributes", toMultiValue(productAttributes.toList(), "multi"))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (findValue != null) {
                    put("find_value", listOf(findValue.toString()))
                }
                if (findWhere != null) {
                    put("find_where", listOf(findWhere.toString()))
                }
                if (useLatestApiVersion != null) {
                    put("use_latest_api_version", listOf(useLatestApiVersion.toString()))
                }
                if (returnGlobal != null) {
                    put("return_global", listOf(returnGlobal.toString()))
                }
                if (categoriesIds != null) {
                    put("categories_ids", listOf(categoriesIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.manufacturer.add
     * Add manufacturer to store and assign to product
     * @param productId Defines products specified by product id
     * @param manufacturer Defines product’s manufacturer&#39;s name
     * @param storeId Store Id (optional)
     * @return ProductManufacturerAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productManufacturerAdd(productId: kotlin.String, manufacturer: kotlin.String, storeId: kotlin.String? = null) : ProductManufacturerAdd200Response {
        val localVarResponse = productManufacturerAddWithHttpInfo(productId = productId, manufacturer = manufacturer, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductManufacturerAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.manufacturer.add
     * Add manufacturer to store and assign to product
     * @param productId Defines products specified by product id
     * @param manufacturer Defines product’s manufacturer&#39;s name
     * @param storeId Store Id (optional)
     * @return ApiResponse<ProductManufacturerAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productManufacturerAddWithHttpInfo(productId: kotlin.String, manufacturer: kotlin.String, storeId: kotlin.String?) : ApiResponse<ProductManufacturerAdd200Response?> {
        val localVariableConfig = productManufacturerAddRequestConfig(productId = productId, manufacturer = manufacturer, storeId = storeId)

        return request<Unit, ProductManufacturerAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productManufacturerAdd
     *
     * @param productId Defines products specified by product id
     * @param manufacturer Defines product’s manufacturer&#39;s name
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productManufacturerAddRequestConfig(productId: kotlin.String, manufacturer: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                put("manufacturer", listOf(manufacturer.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.manufacturer.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.option.add
     * Add product option from store.
     * @param productOptionAdd 
     * @return ProductOptionAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productOptionAdd(productOptionAdd: ProductOptionAdd) : ProductOptionAdd200Response {
        val localVarResponse = productOptionAddWithHttpInfo(productOptionAdd = productOptionAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductOptionAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.option.add
     * Add product option from store.
     * @param productOptionAdd 
     * @return ApiResponse<ProductOptionAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productOptionAddWithHttpInfo(productOptionAdd: ProductOptionAdd) : ApiResponse<ProductOptionAdd200Response?> {
        val localVariableConfig = productOptionAddRequestConfig(productOptionAdd = productOptionAdd)

        return request<ProductOptionAdd, ProductOptionAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productOptionAdd
     *
     * @param productOptionAdd 
     * @return RequestConfig
     */
    fun productOptionAddRequestConfig(productOptionAdd: ProductOptionAdd) : RequestConfig<ProductOptionAdd> {
        val localVariableBody = productOptionAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.option.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.option.assign
     * Assign option from product.
     * @param productId Defines product id where the option should be assigned
     * @param optionId Defines option id which has to be assigned
     * @param required Defines if the option is required (optional, default to false)
     * @param sortOrder Sort number in the list (optional, default to 0)
     * @param optionValues Defines option values that has to be assigned (optional)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return ProductOptionAssign200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productOptionAssign(productId: kotlin.String, optionId: kotlin.String, required: kotlin.Boolean? = false, sortOrder: kotlin.Int? = 0, optionValues: kotlin.String? = null, clearCache: kotlin.Boolean? = true) : ProductOptionAssign200Response {
        val localVarResponse = productOptionAssignWithHttpInfo(productId = productId, optionId = optionId, required = required, sortOrder = sortOrder, optionValues = optionValues, clearCache = clearCache)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductOptionAssign200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.option.assign
     * Assign option from product.
     * @param productId Defines product id where the option should be assigned
     * @param optionId Defines option id which has to be assigned
     * @param required Defines if the option is required (optional, default to false)
     * @param sortOrder Sort number in the list (optional, default to 0)
     * @param optionValues Defines option values that has to be assigned (optional)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return ApiResponse<ProductOptionAssign200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productOptionAssignWithHttpInfo(productId: kotlin.String, optionId: kotlin.String, required: kotlin.Boolean?, sortOrder: kotlin.Int?, optionValues: kotlin.String?, clearCache: kotlin.Boolean?) : ApiResponse<ProductOptionAssign200Response?> {
        val localVariableConfig = productOptionAssignRequestConfig(productId = productId, optionId = optionId, required = required, sortOrder = sortOrder, optionValues = optionValues, clearCache = clearCache)

        return request<Unit, ProductOptionAssign200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productOptionAssign
     *
     * @param productId Defines product id where the option should be assigned
     * @param optionId Defines option id which has to be assigned
     * @param required Defines if the option is required (optional, default to false)
     * @param sortOrder Sort number in the list (optional, default to 0)
     * @param optionValues Defines option values that has to be assigned (optional)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return RequestConfig
     */
    fun productOptionAssignRequestConfig(productId: kotlin.String, optionId: kotlin.String, required: kotlin.Boolean?, sortOrder: kotlin.Int?, optionValues: kotlin.String?, clearCache: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                put("option_id", listOf(optionId.toString()))
                if (required != null) {
                    put("required", listOf(required.toString()))
                }
                if (sortOrder != null) {
                    put("sort_order", listOf(sortOrder.toString()))
                }
                if (optionValues != null) {
                    put("option_values", listOf(optionValues.toString()))
                }
                if (clearCache != null) {
                    put("clear_cache", listOf(clearCache.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.option.assign.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.option.delete
     * Product option delete.
     * @param optionId Defines option id that should be deleted
     * @param productId Defines product id where the option should be deleted
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productOptionDelete(optionId: kotlin.String, productId: kotlin.String, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = productOptionDeleteWithHttpInfo(optionId = optionId, productId = productId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.option.delete
     * Product option delete.
     * @param optionId Defines option id that should be deleted
     * @param productId Defines product id where the option should be deleted
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productOptionDeleteWithHttpInfo(optionId: kotlin.String, productId: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = productOptionDeleteRequestConfig(optionId = optionId, productId = productId, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productOptionDelete
     *
     * @param optionId Defines option id that should be deleted
     * @param productId Defines product id where the option should be deleted
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productOptionDeleteRequestConfig(optionId: kotlin.String, productId: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("option_id", listOf(optionId.toString()))
                put("product_id", listOf(productId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/product.option.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.option.list
     * Get list of options.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param productId Retrieves products&#39; options specified by product id (optional)
     * @param langId Language id (optional)
     * @param storeId Store Id (optional)
     * @return ModelResponseProductOptionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productOptionList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, params: kotlin.String? = "id,name,description", exclude: kotlin.String? = null, responseFields: kotlin.String? = null, productId: kotlin.String? = null, langId: kotlin.String? = null, storeId: kotlin.String? = null) : ModelResponseProductOptionList {
        val localVarResponse = productOptionListWithHttpInfo(start = start, count = count, params = params, exclude = exclude, responseFields = responseFields, productId = productId, langId = langId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseProductOptionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.option.list
     * Get list of options.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param productId Retrieves products&#39; options specified by product id (optional)
     * @param langId Language id (optional)
     * @param storeId Store Id (optional)
     * @return ApiResponse<ModelResponseProductOptionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productOptionListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?, productId: kotlin.String?, langId: kotlin.String?, storeId: kotlin.String?) : ApiResponse<ModelResponseProductOptionList?> {
        val localVariableConfig = productOptionListRequestConfig(start = start, count = count, params = params, exclude = exclude, responseFields = responseFields, productId = productId, langId = langId, storeId = storeId)

        return request<Unit, ModelResponseProductOptionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productOptionList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param productId Retrieves products&#39; options specified by product id (optional)
     * @param langId Language id (optional)
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productOptionListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?, productId: kotlin.String?, langId: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (productId != null) {
                    put("product_id", listOf(productId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.option.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.option.value.add
     * Add product option item from option.
     * @param productId Defines product id where the option value should be added
     * @param optionId Defines option id where the value has to be added
     * @param optionValue Defines option value that has to be added (optional)
     * @param sortOrder Sort number in the list (optional, default to 0)
     * @param displayValue Defines the value that will be displayed for the option value (optional)
     * @param isDefault Defines as a default (optional)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return ProductOptionValueAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productOptionValueAdd(productId: kotlin.String, optionId: kotlin.String, optionValue: kotlin.String? = null, sortOrder: kotlin.Int? = 0, displayValue: kotlin.String? = null, isDefault: kotlin.Boolean? = null, clearCache: kotlin.Boolean? = true) : ProductOptionValueAdd200Response {
        val localVarResponse = productOptionValueAddWithHttpInfo(productId = productId, optionId = optionId, optionValue = optionValue, sortOrder = sortOrder, displayValue = displayValue, isDefault = isDefault, clearCache = clearCache)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductOptionValueAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.option.value.add
     * Add product option item from option.
     * @param productId Defines product id where the option value should be added
     * @param optionId Defines option id where the value has to be added
     * @param optionValue Defines option value that has to be added (optional)
     * @param sortOrder Sort number in the list (optional, default to 0)
     * @param displayValue Defines the value that will be displayed for the option value (optional)
     * @param isDefault Defines as a default (optional)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return ApiResponse<ProductOptionValueAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productOptionValueAddWithHttpInfo(productId: kotlin.String, optionId: kotlin.String, optionValue: kotlin.String?, sortOrder: kotlin.Int?, displayValue: kotlin.String?, isDefault: kotlin.Boolean?, clearCache: kotlin.Boolean?) : ApiResponse<ProductOptionValueAdd200Response?> {
        val localVariableConfig = productOptionValueAddRequestConfig(productId = productId, optionId = optionId, optionValue = optionValue, sortOrder = sortOrder, displayValue = displayValue, isDefault = isDefault, clearCache = clearCache)

        return request<Unit, ProductOptionValueAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productOptionValueAdd
     *
     * @param productId Defines product id where the option value should be added
     * @param optionId Defines option id where the value has to be added
     * @param optionValue Defines option value that has to be added (optional)
     * @param sortOrder Sort number in the list (optional, default to 0)
     * @param displayValue Defines the value that will be displayed for the option value (optional)
     * @param isDefault Defines as a default (optional)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return RequestConfig
     */
    fun productOptionValueAddRequestConfig(productId: kotlin.String, optionId: kotlin.String, optionValue: kotlin.String?, sortOrder: kotlin.Int?, displayValue: kotlin.String?, isDefault: kotlin.Boolean?, clearCache: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                put("option_id", listOf(optionId.toString()))
                if (optionValue != null) {
                    put("option_value", listOf(optionValue.toString()))
                }
                if (sortOrder != null) {
                    put("sort_order", listOf(sortOrder.toString()))
                }
                if (displayValue != null) {
                    put("display_value", listOf(displayValue.toString()))
                }
                if (isDefault != null) {
                    put("is_default", listOf(isDefault.toString()))
                }
                if (clearCache != null) {
                    put("clear_cache", listOf(clearCache.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.option.value.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.option.value.assign
     * Assign product option item from product.
     * @param productOptionId Defines product&#39;s option id where the value has to be assigned
     * @param optionValueId Defines value id that has to be assigned
     * @param clearCache Is cache clear required (optional, default to true)
     * @return ProductOptionValueAssign200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productOptionValueAssign(productOptionId: kotlin.Int, optionValueId: kotlin.String, clearCache: kotlin.Boolean? = true) : ProductOptionValueAssign200Response {
        val localVarResponse = productOptionValueAssignWithHttpInfo(productOptionId = productOptionId, optionValueId = optionValueId, clearCache = clearCache)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductOptionValueAssign200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.option.value.assign
     * Assign product option item from product.
     * @param productOptionId Defines product&#39;s option id where the value has to be assigned
     * @param optionValueId Defines value id that has to be assigned
     * @param clearCache Is cache clear required (optional, default to true)
     * @return ApiResponse<ProductOptionValueAssign200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productOptionValueAssignWithHttpInfo(productOptionId: kotlin.Int, optionValueId: kotlin.String, clearCache: kotlin.Boolean?) : ApiResponse<ProductOptionValueAssign200Response?> {
        val localVariableConfig = productOptionValueAssignRequestConfig(productOptionId = productOptionId, optionValueId = optionValueId, clearCache = clearCache)

        return request<Unit, ProductOptionValueAssign200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productOptionValueAssign
     *
     * @param productOptionId Defines product&#39;s option id where the value has to be assigned
     * @param optionValueId Defines value id that has to be assigned
     * @param clearCache Is cache clear required (optional, default to true)
     * @return RequestConfig
     */
    fun productOptionValueAssignRequestConfig(productOptionId: kotlin.Int, optionValueId: kotlin.String, clearCache: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_option_id", listOf(productOptionId.toString()))
                put("option_value_id", listOf(optionValueId.toString()))
                if (clearCache != null) {
                    put("clear_cache", listOf(clearCache.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.option.value.assign.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.option.value.delete
     * Product option value delete.
     * @param optionId Defines option id where the value should be deleted
     * @param optionValueId Defines option value id that should be deleted
     * @param productId Defines product id where the option value should be deleted
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productOptionValueDelete(optionId: kotlin.String, optionValueId: kotlin.String, productId: kotlin.String, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = productOptionValueDeleteWithHttpInfo(optionId = optionId, optionValueId = optionValueId, productId = productId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.option.value.delete
     * Product option value delete.
     * @param optionId Defines option id where the value should be deleted
     * @param optionValueId Defines option value id that should be deleted
     * @param productId Defines product id where the option value should be deleted
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productOptionValueDeleteWithHttpInfo(optionId: kotlin.String, optionValueId: kotlin.String, productId: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = productOptionValueDeleteRequestConfig(optionId = optionId, optionValueId = optionValueId, productId = productId, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productOptionValueDelete
     *
     * @param optionId Defines option id where the value should be deleted
     * @param optionValueId Defines option value id that should be deleted
     * @param productId Defines product id where the option value should be deleted
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productOptionValueDeleteRequestConfig(optionId: kotlin.String, optionValueId: kotlin.String, productId: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("option_id", listOf(optionId.toString()))
                put("option_value_id", listOf(optionValueId.toString()))
                put("product_id", listOf(productId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/product.option.value.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.option.value.update
     * Update product option item from option.
     * @param productId Defines product id where the option value should be updated
     * @param optionId Defines option id where the value has to be updated
     * @param optionValueId Defines value id that has to be assigned
     * @param optionValue Defines option value that has to be added (optional)
     * @param price Defines new product option price (optional)
     * @param quantity Defines new products&#39; options quantity (optional)
     * @param displayValue Defines the value that will be displayed for the option value (optional)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productOptionValueUpdate(productId: kotlin.String, optionId: kotlin.String, optionValueId: kotlin.String, optionValue: kotlin.String? = null, price: java.math.BigDecimal? = null, quantity: java.math.BigDecimal? = null, displayValue: kotlin.String? = null, clearCache: kotlin.Boolean? = true) : AccountConfigUpdate200Response {
        val localVarResponse = productOptionValueUpdateWithHttpInfo(productId = productId, optionId = optionId, optionValueId = optionValueId, optionValue = optionValue, price = price, quantity = quantity, displayValue = displayValue, clearCache = clearCache)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.option.value.update
     * Update product option item from option.
     * @param productId Defines product id where the option value should be updated
     * @param optionId Defines option id where the value has to be updated
     * @param optionValueId Defines value id that has to be assigned
     * @param optionValue Defines option value that has to be added (optional)
     * @param price Defines new product option price (optional)
     * @param quantity Defines new products&#39; options quantity (optional)
     * @param displayValue Defines the value that will be displayed for the option value (optional)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productOptionValueUpdateWithHttpInfo(productId: kotlin.String, optionId: kotlin.String, optionValueId: kotlin.String, optionValue: kotlin.String?, price: java.math.BigDecimal?, quantity: java.math.BigDecimal?, displayValue: kotlin.String?, clearCache: kotlin.Boolean?) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = productOptionValueUpdateRequestConfig(productId = productId, optionId = optionId, optionValueId = optionValueId, optionValue = optionValue, price = price, quantity = quantity, displayValue = displayValue, clearCache = clearCache)

        return request<Unit, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productOptionValueUpdate
     *
     * @param productId Defines product id where the option value should be updated
     * @param optionId Defines option id where the value has to be updated
     * @param optionValueId Defines value id that has to be assigned
     * @param optionValue Defines option value that has to be added (optional)
     * @param price Defines new product option price (optional)
     * @param quantity Defines new products&#39; options quantity (optional)
     * @param displayValue Defines the value that will be displayed for the option value (optional)
     * @param clearCache Is cache clear required (optional, default to true)
     * @return RequestConfig
     */
    fun productOptionValueUpdateRequestConfig(productId: kotlin.String, optionId: kotlin.String, optionValueId: kotlin.String, optionValue: kotlin.String?, price: java.math.BigDecimal?, quantity: java.math.BigDecimal?, displayValue: kotlin.String?, clearCache: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                put("option_id", listOf(optionId.toString()))
                put("option_value_id", listOf(optionValueId.toString()))
                if (optionValue != null) {
                    put("option_value", listOf(optionValue.toString()))
                }
                if (price != null) {
                    put("price", listOf(price.toString()))
                }
                if (quantity != null) {
                    put("quantity", listOf(quantity.toString()))
                }
                if (displayValue != null) {
                    put("display_value", listOf(displayValue.toString()))
                }
                if (clearCache != null) {
                    put("clear_cache", listOf(clearCache.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/product.option.value.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.price.add
     * Add some prices to the product.
     * @param productPriceAdd 
     * @return CartValidate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productPriceAdd(productPriceAdd: ProductPriceAdd) : CartValidate200Response {
        val localVarResponse = productPriceAddWithHttpInfo(productPriceAdd = productPriceAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartValidate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.price.add
     * Add some prices to the product.
     * @param productPriceAdd 
     * @return ApiResponse<CartValidate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productPriceAddWithHttpInfo(productPriceAdd: ProductPriceAdd) : ApiResponse<CartValidate200Response?> {
        val localVariableConfig = productPriceAddRequestConfig(productPriceAdd = productPriceAdd)

        return request<ProductPriceAdd, CartValidate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productPriceAdd
     *
     * @param productPriceAdd 
     * @return RequestConfig
     */
    fun productPriceAddRequestConfig(productPriceAdd: ProductPriceAdd) : RequestConfig<ProductPriceAdd> {
        val localVariableBody = productPriceAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.price.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.price.delete
     * Delete some prices of the product
     * @param productId Defines the product where the price has to be deleted
     * @param groupPrices Defines product&#39;s group prices (optional)
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productPriceDelete(productId: kotlin.String, groupPrices: kotlin.String? = null, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = productPriceDeleteWithHttpInfo(productId = productId, groupPrices = groupPrices, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.price.delete
     * Delete some prices of the product
     * @param productId Defines the product where the price has to be deleted
     * @param groupPrices Defines product&#39;s group prices (optional)
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productPriceDeleteWithHttpInfo(productId: kotlin.String, groupPrices: kotlin.String?, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = productPriceDeleteRequestConfig(productId = productId, groupPrices = groupPrices, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productPriceDelete
     *
     * @param productId Defines the product where the price has to be deleted
     * @param groupPrices Defines product&#39;s group prices (optional)
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productPriceDeleteRequestConfig(productId: kotlin.String, groupPrices: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                if (groupPrices != null) {
                    put("group_prices", listOf(groupPrices.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/product.price.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.price.update
     * Update some prices of the product.
     * @param productPriceUpdate 
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productPriceUpdate(productPriceUpdate: ProductPriceUpdate) : AccountConfigUpdate200Response {
        val localVarResponse = productPriceUpdateWithHttpInfo(productPriceUpdate = productPriceUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.price.update
     * Update some prices of the product.
     * @param productPriceUpdate 
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productPriceUpdateWithHttpInfo(productPriceUpdate: ProductPriceUpdate) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = productPriceUpdateRequestConfig(productPriceUpdate = productPriceUpdate)

        return request<ProductPriceUpdate, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productPriceUpdate
     *
     * @param productPriceUpdate 
     * @return RequestConfig
     */
    fun productPriceUpdateRequestConfig(productPriceUpdate: ProductPriceUpdate) : RequestConfig<ProductPriceUpdate> {
        val localVariableBody = productPriceUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/product.price.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.review.list
     * Get reviews of a specific product.
     * @param productId Product id
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param ids Retrieves reviews specified by ids (optional)
     * @param storeId Store Id (optional)
     * @param status Defines status (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return ModelResponseProductReviewList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productReviewList(productId: kotlin.String, start: kotlin.Int? = 0, pageCursor: kotlin.String? = null, count: kotlin.Int? = 10, ids: kotlin.String? = null, storeId: kotlin.String? = null, status: kotlin.String? = null, params: kotlin.String? = "id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time", exclude: kotlin.String? = null, responseFields: kotlin.String? = null) : ModelResponseProductReviewList {
        val localVarResponse = productReviewListWithHttpInfo(productId = productId, start = start, pageCursor = pageCursor, count = count, ids = ids, storeId = storeId, status = status, params = params, exclude = exclude, responseFields = responseFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseProductReviewList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.review.list
     * Get reviews of a specific product.
     * @param productId Product id
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param ids Retrieves reviews specified by ids (optional)
     * @param storeId Store Id (optional)
     * @param status Defines status (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return ApiResponse<ModelResponseProductReviewList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productReviewListWithHttpInfo(productId: kotlin.String, start: kotlin.Int?, pageCursor: kotlin.String?, count: kotlin.Int?, ids: kotlin.String?, storeId: kotlin.String?, status: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?) : ApiResponse<ModelResponseProductReviewList?> {
        val localVariableConfig = productReviewListRequestConfig(productId = productId, start = start, pageCursor = pageCursor, count = count, ids = ids, storeId = storeId, status = status, params = params, exclude = exclude, responseFields = responseFields)

        return request<Unit, ModelResponseProductReviewList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productReviewList
     *
     * @param productId Product id
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param ids Retrieves reviews specified by ids (optional)
     * @param storeId Store Id (optional)
     * @param status Defines status (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @return RequestConfig
     */
    fun productReviewListRequestConfig(productId: kotlin.String, start: kotlin.Int?, pageCursor: kotlin.String?, count: kotlin.Int?, ids: kotlin.String?, storeId: kotlin.String?, status: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?, responseFields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                put("product_id", listOf(productId.toString()))
                if (ids != null) {
                    put("ids", listOf(ids.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.review.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.store.assign
     * Assign product to store
     * @param productId Defines id of the product which should be assigned to a store
     * @param storeId Defines id of the store product should be assigned to
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productStoreAssign(productId: kotlin.String, storeId: kotlin.String) : AccountConfigUpdate200Response {
        val localVarResponse = productStoreAssignWithHttpInfo(productId = productId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.store.assign
     * Assign product to store
     * @param productId Defines id of the product which should be assigned to a store
     * @param storeId Defines id of the store product should be assigned to
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productStoreAssignWithHttpInfo(productId: kotlin.String, storeId: kotlin.String) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = productStoreAssignRequestConfig(productId = productId, storeId = storeId)

        return request<Unit, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productStoreAssign
     *
     * @param productId Defines id of the product which should be assigned to a store
     * @param storeId Defines id of the store product should be assigned to
     * @return RequestConfig
     */
    fun productStoreAssignRequestConfig(productId: kotlin.String, storeId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                put("store_id", listOf(storeId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.store.assign.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.tax.add
     * Add tax class and tax rate to store and assign to product.
     * @param productTaxAdd 
     * @return ProductTaxAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productTaxAdd(productTaxAdd: ProductTaxAdd) : ProductTaxAdd200Response {
        val localVarResponse = productTaxAddWithHttpInfo(productTaxAdd = productTaxAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductTaxAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.tax.add
     * Add tax class and tax rate to store and assign to product.
     * @param productTaxAdd 
     * @return ApiResponse<ProductTaxAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productTaxAddWithHttpInfo(productTaxAdd: ProductTaxAdd) : ApiResponse<ProductTaxAdd200Response?> {
        val localVariableConfig = productTaxAddRequestConfig(productTaxAdd = productTaxAdd)

        return request<ProductTaxAdd, ProductTaxAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productTaxAdd
     *
     * @param productTaxAdd 
     * @return RequestConfig
     */
    fun productTaxAddRequestConfig(productTaxAdd: ProductTaxAdd) : RequestConfig<ProductTaxAdd> {
        val localVariableBody = productTaxAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.tax.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.update
     * This method can be used to update certain product data. The list of supported parameters depends on the specific platform. Please transmit only those parameters that are supported by the particular platform. Please note that to update the product quantity, it is recommended to use relative parameters (increase_quantity or reduce_quantity) to avoid unexpected overwrites on heavily loaded stores.
     * @param productUpdate 
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productUpdate(productUpdate: ProductUpdate) : AccountConfigUpdate200Response {
        val localVarResponse = productUpdateWithHttpInfo(productUpdate = productUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.update
     * This method can be used to update certain product data. The list of supported parameters depends on the specific platform. Please transmit only those parameters that are supported by the particular platform. Please note that to update the product quantity, it is recommended to use relative parameters (increase_quantity or reduce_quantity) to avoid unexpected overwrites on heavily loaded stores.
     * @param productUpdate 
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productUpdateWithHttpInfo(productUpdate: ProductUpdate) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = productUpdateRequestConfig(productUpdate = productUpdate)

        return request<ProductUpdate, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productUpdate
     *
     * @param productUpdate 
     * @return RequestConfig
     */
    fun productUpdateRequestConfig(productUpdate: ProductUpdate) : RequestConfig<ProductUpdate> {
        val localVariableBody = productUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/product.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.update.batch
     * Update products on the store.
     * @param productUpdateBatch 
     * @return CategoryAddBatch200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productUpdateBatch(productUpdateBatch: ProductUpdateBatch) : CategoryAddBatch200Response {
        val localVarResponse = productUpdateBatchWithHttpInfo(productUpdateBatch = productUpdateBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryAddBatch200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.update.batch
     * Update products on the store.
     * @param productUpdateBatch 
     * @return ApiResponse<CategoryAddBatch200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productUpdateBatchWithHttpInfo(productUpdateBatch: ProductUpdateBatch) : ApiResponse<CategoryAddBatch200Response?> {
        val localVariableConfig = productUpdateBatchRequestConfig(productUpdateBatch = productUpdateBatch)

        return request<ProductUpdateBatch, CategoryAddBatch200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productUpdateBatch
     *
     * @param productUpdateBatch 
     * @return RequestConfig
     */
    fun productUpdateBatchRequestConfig(productUpdateBatch: ProductUpdateBatch) : RequestConfig<ProductUpdateBatch> {
        val localVariableBody = productUpdateBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.update.batch.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.add
     * Add variant to product.
     * @param productVariantAdd 
     * @return ProductVariantAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantAdd(productVariantAdd: ProductVariantAdd) : ProductVariantAdd200Response {
        val localVarResponse = productVariantAddWithHttpInfo(productVariantAdd = productVariantAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductVariantAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.add
     * Add variant to product.
     * @param productVariantAdd 
     * @return ApiResponse<ProductVariantAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantAddWithHttpInfo(productVariantAdd: ProductVariantAdd) : ApiResponse<ProductVariantAdd200Response?> {
        val localVariableConfig = productVariantAddRequestConfig(productVariantAdd = productVariantAdd)

        return request<ProductVariantAdd, ProductVariantAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantAdd
     *
     * @param productVariantAdd 
     * @return RequestConfig
     */
    fun productVariantAddRequestConfig(productVariantAdd: ProductVariantAdd) : RequestConfig<ProductVariantAdd> {
        val localVariableBody = productVariantAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.variant.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.add.batch
     * Add new product variants to the store.
     * @param productVariantAddBatch 
     * @return CategoryAddBatch200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantAddBatch(productVariantAddBatch: ProductVariantAddBatch) : CategoryAddBatch200Response {
        val localVarResponse = productVariantAddBatchWithHttpInfo(productVariantAddBatch = productVariantAddBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryAddBatch200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.add.batch
     * Add new product variants to the store.
     * @param productVariantAddBatch 
     * @return ApiResponse<CategoryAddBatch200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantAddBatchWithHttpInfo(productVariantAddBatch: ProductVariantAddBatch) : ApiResponse<CategoryAddBatch200Response?> {
        val localVariableConfig = productVariantAddBatchRequestConfig(productVariantAddBatch = productVariantAddBatch)

        return request<ProductVariantAddBatch, CategoryAddBatch200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantAddBatch
     *
     * @param productVariantAddBatch 
     * @return RequestConfig
     */
    fun productVariantAddBatchRequestConfig(productVariantAddBatch: ProductVariantAddBatch) : RequestConfig<ProductVariantAddBatch> {
        val localVariableBody = productVariantAddBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.variant.add.batch.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.count
     * Get count variants.
     * @param productId Retrieves products&#39; variants specified by product id
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param categoryId Counts products’ variants specified by category id (optional)
     * @param storeId Retrieves variants specified by store id (optional)
     * @return ProductVariantCount200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun productVariantCount(productId: kotlin.String, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, categoryId: kotlin.String? = null, storeId: kotlin.String? = null) : ProductVariantCount200Response {
        @Suppress("DEPRECATION")
        val localVarResponse = productVariantCountWithHttpInfo(productId = productId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, categoryId = categoryId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductVariantCount200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.count
     * Get count variants.
     * @param productId Retrieves products&#39; variants specified by product id
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param categoryId Counts products’ variants specified by category id (optional)
     * @param storeId Retrieves variants specified by store id (optional)
     * @return ApiResponse<ProductVariantCount200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun productVariantCountWithHttpInfo(productId: kotlin.String, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, categoryId: kotlin.String?, storeId: kotlin.String?) : ApiResponse<ProductVariantCount200Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = productVariantCountRequestConfig(productId = productId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, categoryId = categoryId, storeId = storeId)

        return request<Unit, ProductVariantCount200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantCount
     *
     * @param productId Retrieves products&#39; variants specified by product id
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param categoryId Counts products’ variants specified by category id (optional)
     * @param storeId Retrieves variants specified by store id (optional)
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun productVariantCountRequestConfig(productId: kotlin.String, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, categoryId: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (categoryId != null) {
                    put("category_id", listOf(categoryId.toString()))
                }
                put("product_id", listOf(productId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.variant.count.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.delete
     * Delete variant.
     * @param id Defines variant removal, specified by variant id
     * @param productId Defines product&#39;s id where the variant has to be deleted
     * @param storeId Store Id (optional)
     * @return AttributeValueDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantDelete(id: kotlin.String, productId: kotlin.String, storeId: kotlin.String? = null) : AttributeValueDelete200Response {
        val localVarResponse = productVariantDeleteWithHttpInfo(id = id, productId = productId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeValueDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.delete
     * Delete variant.
     * @param id Defines variant removal, specified by variant id
     * @param productId Defines product&#39;s id where the variant has to be deleted
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeValueDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantDeleteWithHttpInfo(id: kotlin.String, productId: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeValueDelete200Response?> {
        val localVariableConfig = productVariantDeleteRequestConfig(id = id, productId = productId, storeId = storeId)

        return request<Unit, AttributeValueDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantDelete
     *
     * @param id Defines variant removal, specified by variant id
     * @param productId Defines product&#39;s id where the variant has to be deleted
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productVariantDeleteRequestConfig(id: kotlin.String, productId: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                put("product_id", listOf(productId.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/product.variant.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.delete.batch
     * Remove product variants from the store.
     * @param productVariantDeleteBatch 
     * @return CategoryAddBatch200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantDeleteBatch(productVariantDeleteBatch: ProductVariantDeleteBatch) : CategoryAddBatch200Response {
        val localVarResponse = productVariantDeleteBatchWithHttpInfo(productVariantDeleteBatch = productVariantDeleteBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryAddBatch200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.delete.batch
     * Remove product variants from the store.
     * @param productVariantDeleteBatch 
     * @return ApiResponse<CategoryAddBatch200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantDeleteBatchWithHttpInfo(productVariantDeleteBatch: ProductVariantDeleteBatch) : ApiResponse<CategoryAddBatch200Response?> {
        val localVariableConfig = productVariantDeleteBatchRequestConfig(productVariantDeleteBatch = productVariantDeleteBatch)

        return request<ProductVariantDeleteBatch, CategoryAddBatch200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantDeleteBatch
     *
     * @param productVariantDeleteBatch 
     * @return RequestConfig
     */
    fun productVariantDeleteBatchRequestConfig(productVariantDeleteBatch: ProductVariantDeleteBatch) : RequestConfig<ProductVariantDeleteBatch> {
        val localVariableBody = productVariantDeleteBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.variant.delete.batch.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.image.add
     * Add image to product
     * @param productVariantImageAdd 
     * @return ProductVariantImageAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantImageAdd(productVariantImageAdd: ProductVariantImageAdd) : ProductVariantImageAdd200Response {
        val localVarResponse = productVariantImageAddWithHttpInfo(productVariantImageAdd = productVariantImageAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductVariantImageAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.image.add
     * Add image to product
     * @param productVariantImageAdd 
     * @return ApiResponse<ProductVariantImageAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantImageAddWithHttpInfo(productVariantImageAdd: ProductVariantImageAdd) : ApiResponse<ProductVariantImageAdd200Response?> {
        val localVariableConfig = productVariantImageAddRequestConfig(productVariantImageAdd = productVariantImageAdd)

        return request<ProductVariantImageAdd, ProductVariantImageAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantImageAdd
     *
     * @param productVariantImageAdd 
     * @return RequestConfig
     */
    fun productVariantImageAddRequestConfig(productVariantImageAdd: ProductVariantImageAdd) : RequestConfig<ProductVariantImageAdd> {
        val localVariableBody = productVariantImageAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.variant.image.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.image.delete
     * Delete  image to product
     * @param productId Defines product id where the variant image should be deleted
     * @param productVariantId Defines product&#39;s variants specified by variant id
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantImageDelete(productId: kotlin.String, productVariantId: kotlin.String, id: kotlin.String, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = productVariantImageDeleteWithHttpInfo(productId = productId, productVariantId = productVariantId, id = id, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.image.delete
     * Delete  image to product
     * @param productId Defines product id where the variant image should be deleted
     * @param productVariantId Defines product&#39;s variants specified by variant id
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantImageDeleteWithHttpInfo(productId: kotlin.String, productVariantId: kotlin.String, id: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = productVariantImageDeleteRequestConfig(productId = productId, productVariantId = productVariantId, id = id, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantImageDelete
     *
     * @param productId Defines product id where the variant image should be deleted
     * @param productVariantId Defines product&#39;s variants specified by variant id
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productVariantImageDeleteRequestConfig(productId: kotlin.String, productVariantId: kotlin.String, id: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("product_id", listOf(productId.toString()))
                put("product_variant_id", listOf(productVariantId.toString()))
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/product.variant.image.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.info
     * Get variant info. This method is deprecated, and its development is stopped. Please use \&quot;product.child_item.info\&quot; instead.
     * @param id Retrieves variant&#39;s info specified by variant id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves variant info specified by store id (optional)
     * @return ProductInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun productVariantInfo(id: kotlin.String, params: kotlin.String? = "id,name,description,price", exclude: kotlin.String? = null, storeId: kotlin.String? = null) : ProductInfo200Response {
        @Suppress("DEPRECATION")
        val localVarResponse = productVariantInfoWithHttpInfo(id = id, params = params, exclude = exclude, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.info
     * Get variant info. This method is deprecated, and its development is stopped. Please use \&quot;product.child_item.info\&quot; instead.
     * @param id Retrieves variant&#39;s info specified by variant id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves variant info specified by store id (optional)
     * @return ApiResponse<ProductInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun productVariantInfoWithHttpInfo(id: kotlin.String, params: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?) : ApiResponse<ProductInfo200Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = productVariantInfoRequestConfig(id = id, params = params, exclude = exclude, storeId = storeId)

        return request<Unit, ProductInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantInfo
     *
     * @param id Retrieves variant&#39;s info specified by variant id
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param storeId Retrieves variant info specified by store id (optional)
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun productVariantInfoRequestConfig(id: kotlin.String, params: kotlin.String?, exclude: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.variant.info.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.list
     * Get a list of variants. This method is deprecated, and its development is stopped. Please use \&quot;product.child_item.list\&quot; instead.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param categoryId Retrieves products’ variants specified by category id (optional)
     * @param productId Retrieves products&#39; variants specified by product id (optional)
     * @param storeId Retrieves variants specified by store id (optional)
     * @return ProductVariantList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun productVariantList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, params: kotlin.String? = "id,name,description,price", exclude: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, categoryId: kotlin.String? = null, productId: kotlin.String? = null, storeId: kotlin.String? = null) : ProductVariantList200Response {
        @Suppress("DEPRECATION")
        val localVarResponse = productVariantListWithHttpInfo(start = start, count = count, params = params, exclude = exclude, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, categoryId = categoryId, productId = productId, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductVariantList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.list
     * Get a list of variants. This method is deprecated, and its development is stopped. Please use \&quot;product.child_item.list\&quot; instead.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param categoryId Retrieves products’ variants specified by category id (optional)
     * @param productId Retrieves products&#39; variants specified by product id (optional)
     * @param storeId Retrieves variants specified by store id (optional)
     * @return ApiResponse<ProductVariantList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun productVariantListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, exclude: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, categoryId: kotlin.String?, productId: kotlin.String?, storeId: kotlin.String?) : ApiResponse<ProductVariantList200Response?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = productVariantListRequestConfig(start = start, count = count, params = params, exclude = exclude, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, categoryId = categoryId, productId = productId, storeId = storeId)

        return request<Unit, ProductVariantList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description,price")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param categoryId Retrieves products’ variants specified by category id (optional)
     * @param productId Retrieves products&#39; variants specified by product id (optional)
     * @param storeId Retrieves variants specified by store id (optional)
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun productVariantListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, params: kotlin.String?, exclude: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, categoryId: kotlin.String?, productId: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (categoryId != null) {
                    put("category_id", listOf(categoryId.toString()))
                }
                if (productId != null) {
                    put("product_id", listOf(productId.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/product.variant.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.price.add
     * Add some prices to the product variant.
     * @param productVariantPriceAdd 
     * @return CartValidate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantPriceAdd(productVariantPriceAdd: ProductVariantPriceAdd) : CartValidate200Response {
        val localVarResponse = productVariantPriceAddWithHttpInfo(productVariantPriceAdd = productVariantPriceAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartValidate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.price.add
     * Add some prices to the product variant.
     * @param productVariantPriceAdd 
     * @return ApiResponse<CartValidate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantPriceAddWithHttpInfo(productVariantPriceAdd: ProductVariantPriceAdd) : ApiResponse<CartValidate200Response?> {
        val localVariableConfig = productVariantPriceAddRequestConfig(productVariantPriceAdd = productVariantPriceAdd)

        return request<ProductVariantPriceAdd, CartValidate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantPriceAdd
     *
     * @param productVariantPriceAdd 
     * @return RequestConfig
     */
    fun productVariantPriceAddRequestConfig(productVariantPriceAdd: ProductVariantPriceAdd) : RequestConfig<ProductVariantPriceAdd> {
        val localVariableBody = productVariantPriceAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.variant.price.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.price.delete
     * Delete some prices of the product variant.
     * @param id Defines the variant where the price has to be deleted
     * @param productId Product id
     * @param groupPrices Defines variants&#39;s group prices
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantPriceDelete(id: kotlin.String, productId: kotlin.String, groupPrices: kotlin.String, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = productVariantPriceDeleteWithHttpInfo(id = id, productId = productId, groupPrices = groupPrices, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.price.delete
     * Delete some prices of the product variant.
     * @param id Defines the variant where the price has to be deleted
     * @param productId Product id
     * @param groupPrices Defines variants&#39;s group prices
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantPriceDeleteWithHttpInfo(id: kotlin.String, productId: kotlin.String, groupPrices: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = productVariantPriceDeleteRequestConfig(id = id, productId = productId, groupPrices = groupPrices, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantPriceDelete
     *
     * @param id Defines the variant where the price has to be deleted
     * @param productId Product id
     * @param groupPrices Defines variants&#39;s group prices
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun productVariantPriceDeleteRequestConfig(id: kotlin.String, productId: kotlin.String, groupPrices: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                put("product_id", listOf(productId.toString()))
                put("group_prices", listOf(groupPrices.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/product.variant.price.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.price.update
     * Update some prices of the product variant.
     * @param productVariantPriceUpdate 
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantPriceUpdate(productVariantPriceUpdate: ProductVariantPriceUpdate) : AccountConfigUpdate200Response {
        val localVarResponse = productVariantPriceUpdateWithHttpInfo(productVariantPriceUpdate = productVariantPriceUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.price.update
     * Update some prices of the product variant.
     * @param productVariantPriceUpdate 
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantPriceUpdateWithHttpInfo(productVariantPriceUpdate: ProductVariantPriceUpdate) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = productVariantPriceUpdateRequestConfig(productVariantPriceUpdate = productVariantPriceUpdate)

        return request<ProductVariantPriceUpdate, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantPriceUpdate
     *
     * @param productVariantPriceUpdate 
     * @return RequestConfig
     */
    fun productVariantPriceUpdateRequestConfig(productVariantPriceUpdate: ProductVariantPriceUpdate) : RequestConfig<ProductVariantPriceUpdate> {
        val localVariableBody = productVariantPriceUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/product.variant.price.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.update
     * Update variant.
     * @param productVariantUpdate 
     * @return AccountConfigUpdate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantUpdate(productVariantUpdate: ProductVariantUpdate) : AccountConfigUpdate200Response {
        val localVarResponse = productVariantUpdateWithHttpInfo(productVariantUpdate = productVariantUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountConfigUpdate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.update
     * Update variant.
     * @param productVariantUpdate 
     * @return ApiResponse<AccountConfigUpdate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantUpdateWithHttpInfo(productVariantUpdate: ProductVariantUpdate) : ApiResponse<AccountConfigUpdate200Response?> {
        val localVariableConfig = productVariantUpdateRequestConfig(productVariantUpdate = productVariantUpdate)

        return request<ProductVariantUpdate, AccountConfigUpdate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantUpdate
     *
     * @param productVariantUpdate 
     * @return RequestConfig
     */
    fun productVariantUpdateRequestConfig(productVariantUpdate: ProductVariantUpdate) : RequestConfig<ProductVariantUpdate> {
        val localVariableBody = productVariantUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/product.variant.update.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * product.variant.update.batch
     * Update products variants on the store.
     * @param productVariantUpdateBatch 
     * @return CategoryAddBatch200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productVariantUpdateBatch(productVariantUpdateBatch: ProductVariantUpdateBatch) : CategoryAddBatch200Response {
        val localVarResponse = productVariantUpdateBatchWithHttpInfo(productVariantUpdateBatch = productVariantUpdateBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CategoryAddBatch200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * product.variant.update.batch
     * Update products variants on the store.
     * @param productVariantUpdateBatch 
     * @return ApiResponse<CategoryAddBatch200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productVariantUpdateBatchWithHttpInfo(productVariantUpdateBatch: ProductVariantUpdateBatch) : ApiResponse<CategoryAddBatch200Response?> {
        val localVariableConfig = productVariantUpdateBatchRequestConfig(productVariantUpdateBatch = productVariantUpdateBatch)

        return request<ProductVariantUpdateBatch, CategoryAddBatch200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productVariantUpdateBatch
     *
     * @param productVariantUpdateBatch 
     * @return RequestConfig
     */
    fun productVariantUpdateBatchRequestConfig(productVariantUpdateBatch: ProductVariantUpdateBatch) : RequestConfig<ProductVariantUpdateBatch> {
        val localVariableBody = productVariantUpdateBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/product.variant.update.batch.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
