/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AttributeAdd200Response
import org.openapitools.client.models.AttributeDelete200Response
import org.openapitools.client.models.BasketLiveShippingServiceDelete200Response
import org.openapitools.client.models.CartCatalogPriceRulesCount200Response
import org.openapitools.client.models.CartCouponAdd
import org.openapitools.client.models.CartCouponAdd200Response
import org.openapitools.client.models.CartCouponCount200Response
import org.openapitools.client.models.CartDelete200Response
import org.openapitools.client.models.CartGiftcardAdd200Response
import org.openapitools.client.models.CartGiftcardCount200Response
import org.openapitools.client.models.CartInfo200Response
import org.openapitools.client.models.CartMethods200Response
import org.openapitools.client.models.CartPluginList200Response
import org.openapitools.client.models.CartScriptAdd200Response
import org.openapitools.client.models.CartValidate200Response
import org.openapitools.client.models.ModelResponseCartCatalogPriceRulesList
import org.openapitools.client.models.ModelResponseCartCouponList
import org.openapitools.client.models.ModelResponseCartGiftCardList
import org.openapitools.client.models.ModelResponseCartMetaDataList
import org.openapitools.client.models.ModelResponseCartScriptList
import org.openapitools.client.models.ModelResponseCartShippingZonesList

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class CartApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.api2cart.local.com/v1.1")
        }
    }

    /**
     * cart.catalog_price_rules.count
     * Get count of cart catalog price rules discounts.
     * @return CartCatalogPriceRulesCount200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartCatalogPriceRulesCount() : CartCatalogPriceRulesCount200Response {
        val localVarResponse = cartCatalogPriceRulesCountWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartCatalogPriceRulesCount200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.catalog_price_rules.count
     * Get count of cart catalog price rules discounts.
     * @return ApiResponse<CartCatalogPriceRulesCount200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartCatalogPriceRulesCountWithHttpInfo() : ApiResponse<CartCatalogPriceRulesCount200Response?> {
        val localVariableConfig = cartCatalogPriceRulesCountRequestConfig()

        return request<Unit, CartCatalogPriceRulesCount200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartCatalogPriceRulesCount
     *
     * @return RequestConfig
     */
    fun cartCatalogPriceRulesCountRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.catalog_price_rules.count.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.catalog_price_rules.list
     * Get cart catalog price rules discounts.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param ids Retrieves  catalog_price_rules by ids (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseCartCatalogPriceRulesList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartCatalogPriceRulesList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, ids: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "id,name,description", exclude: kotlin.String? = null) : ModelResponseCartCatalogPriceRulesList {
        val localVarResponse = cartCatalogPriceRulesListWithHttpInfo(start = start, count = count, pageCursor = pageCursor, ids = ids, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCartCatalogPriceRulesList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.catalog_price_rules.list
     * Get cart catalog price rules discounts.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param ids Retrieves  catalog_price_rules by ids (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseCartCatalogPriceRulesList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartCatalogPriceRulesListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, ids: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseCartCatalogPriceRulesList?> {
        val localVariableConfig = cartCatalogPriceRulesListRequestConfig(start = start, count = count, pageCursor = pageCursor, ids = ids, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseCartCatalogPriceRulesList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartCatalogPriceRulesList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param ids Retrieves  catalog_price_rules by ids (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun cartCatalogPriceRulesListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, ids: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (ids != null) {
                    put("ids", listOf(ids.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.catalog_price_rules.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.coupon.add
     * Use this method to create a coupon with specified conditions.
     * @param cartCouponAdd 
     * @return CartCouponAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartCouponAdd(cartCouponAdd: CartCouponAdd) : CartCouponAdd200Response {
        val localVarResponse = cartCouponAddWithHttpInfo(cartCouponAdd = cartCouponAdd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartCouponAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.coupon.add
     * Use this method to create a coupon with specified conditions.
     * @param cartCouponAdd 
     * @return ApiResponse<CartCouponAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartCouponAddWithHttpInfo(cartCouponAdd: CartCouponAdd) : ApiResponse<CartCouponAdd200Response?> {
        val localVariableConfig = cartCouponAddRequestConfig(cartCouponAdd = cartCouponAdd)

        return request<CartCouponAdd, CartCouponAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartCouponAdd
     *
     * @param cartCouponAdd 
     * @return RequestConfig
     */
    fun cartCouponAddRequestConfig(cartCouponAdd: CartCouponAdd) : RequestConfig<CartCouponAdd> {
        val localVariableBody = cartCouponAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cart.coupon.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter entity
     */
     enum class EntityCartCouponConditionAdd(val value: kotlin.String) {
         @Json(name = "order") order("order"),
         @Json(name = "order_shipping_address") order_shipping_address("order_shipping_address"),
         @Json(name = "product") product("product"),
         @Json(name = "customer") customer("customer");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter key
     */
     enum class KeyCartCouponConditionAdd(val value: kotlin.String) {
         @Json(name = "total") total("total"),
         @Json(name = "subtotal") subtotal("subtotal"),
         @Json(name = "shipping_total") shipping_total("shipping_total"),
         @Json(name = "total_quantity") total_quantity("total_quantity"),
         @Json(name = "total_weight") total_weight("total_weight"),
         @Json(name = "country") country("country"),
         @Json(name = "product_id") product_id("product_id"),
         @Json(name = "variant_id") variant_id("variant_id"),
         @Json(name = "category_id") category_id("category_id"),
         @Json(name = "customer_id") customer_id("customer_id"),
         @Json(name = "item_price") item_price("item_price"),
         @Json(name = "item_total_price") item_total_price("item_total_price"),
         @Json(name = "item_quantity") item_quantity("item_quantity"),
         @Json(name = "carrier_id") carrier_id("carrier_id");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * cart.coupon.condition.add
     * Use this method to add additional conditions for coupon application.
     * @param couponId Coupon Id
     * @param entity Defines condition entity type
     * @param key Defines condition entity attribute key
     * @param `operator` Defines condition operator
     * @param `value` Defines condition value, can be comma separated according to the operator.
     * @param target Defines condition operator (optional, default to "coupon_prerequisite")
     * @param includeTax Indicates whether to apply a discount for taxes. (optional, default to false)
     * @param includeShipping Indicates whether to apply a discount for shipping. (optional, default to false)
     * @param storeId Store Id (optional)
     * @return BasketLiveShippingServiceDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartCouponConditionAdd(couponId: kotlin.String, entity: EntityCartCouponConditionAdd, key: KeyCartCouponConditionAdd, `operator`: kotlin.String, `value`: kotlin.String, target: kotlin.String? = "coupon_prerequisite", includeTax: kotlin.Boolean? = false, includeShipping: kotlin.Boolean? = false, storeId: kotlin.String? = null) : BasketLiveShippingServiceDelete200Response {
        val localVarResponse = cartCouponConditionAddWithHttpInfo(couponId = couponId, entity = entity, key = key, `operator` = `operator`, `value` = `value`, target = target, includeTax = includeTax, includeShipping = includeShipping, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BasketLiveShippingServiceDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.coupon.condition.add
     * Use this method to add additional conditions for coupon application.
     * @param couponId Coupon Id
     * @param entity Defines condition entity type
     * @param key Defines condition entity attribute key
     * @param `operator` Defines condition operator
     * @param `value` Defines condition value, can be comma separated according to the operator.
     * @param target Defines condition operator (optional, default to "coupon_prerequisite")
     * @param includeTax Indicates whether to apply a discount for taxes. (optional, default to false)
     * @param includeShipping Indicates whether to apply a discount for shipping. (optional, default to false)
     * @param storeId Store Id (optional)
     * @return ApiResponse<BasketLiveShippingServiceDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartCouponConditionAddWithHttpInfo(couponId: kotlin.String, entity: EntityCartCouponConditionAdd, key: KeyCartCouponConditionAdd, `operator`: kotlin.String, `value`: kotlin.String, target: kotlin.String?, includeTax: kotlin.Boolean?, includeShipping: kotlin.Boolean?, storeId: kotlin.String?) : ApiResponse<BasketLiveShippingServiceDelete200Response?> {
        val localVariableConfig = cartCouponConditionAddRequestConfig(couponId = couponId, entity = entity, key = key, `operator` = `operator`, `value` = `value`, target = target, includeTax = includeTax, includeShipping = includeShipping, storeId = storeId)

        return request<Unit, BasketLiveShippingServiceDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartCouponConditionAdd
     *
     * @param couponId Coupon Id
     * @param entity Defines condition entity type
     * @param key Defines condition entity attribute key
     * @param `operator` Defines condition operator
     * @param `value` Defines condition value, can be comma separated according to the operator.
     * @param target Defines condition operator (optional, default to "coupon_prerequisite")
     * @param includeTax Indicates whether to apply a discount for taxes. (optional, default to false)
     * @param includeShipping Indicates whether to apply a discount for shipping. (optional, default to false)
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun cartCouponConditionAddRequestConfig(couponId: kotlin.String, entity: EntityCartCouponConditionAdd, key: KeyCartCouponConditionAdd, `operator`: kotlin.String, `value`: kotlin.String, target: kotlin.String?, includeTax: kotlin.Boolean?, includeShipping: kotlin.Boolean?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("coupon_id", listOf(couponId.toString()))
                put("entity", listOf(entity.value))
                put("key", listOf(key.value))
                put("operator", listOf(`operator`.toString()))
                put("value", listOf(`value`.toString()))
                if (target != null) {
                    put("target", listOf(target.toString()))
                }
                if (includeTax != null) {
                    put("include_tax", listOf(includeTax.toString()))
                }
                if (includeShipping != null) {
                    put("include_shipping", listOf(includeShipping.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cart.coupon.condition.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.coupon.count
     * This method allows you to get the number of coupons. On some platforms, you can filter the coupons by the date they were active.
     * @param storeId Store Id (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param dateStartFrom Filter entity by date_start (greater or equal) (optional)
     * @param dateStartTo Filter entity by date_start (less or equal) (optional)
     * @param dateEndFrom Filter entity by date_end (greater or equal) (optional)
     * @param dateEndTo Filter entity by date_end (less or equal) (optional)
     * @return CartCouponCount200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartCouponCount(storeId: kotlin.String? = null, avail: kotlin.Boolean? = true, dateStartFrom: kotlin.String? = null, dateStartTo: kotlin.String? = null, dateEndFrom: kotlin.String? = null, dateEndTo: kotlin.String? = null) : CartCouponCount200Response {
        val localVarResponse = cartCouponCountWithHttpInfo(storeId = storeId, avail = avail, dateStartFrom = dateStartFrom, dateStartTo = dateStartTo, dateEndFrom = dateEndFrom, dateEndTo = dateEndTo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartCouponCount200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.coupon.count
     * This method allows you to get the number of coupons. On some platforms, you can filter the coupons by the date they were active.
     * @param storeId Store Id (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param dateStartFrom Filter entity by date_start (greater or equal) (optional)
     * @param dateStartTo Filter entity by date_start (less or equal) (optional)
     * @param dateEndFrom Filter entity by date_end (greater or equal) (optional)
     * @param dateEndTo Filter entity by date_end (less or equal) (optional)
     * @return ApiResponse<CartCouponCount200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartCouponCountWithHttpInfo(storeId: kotlin.String?, avail: kotlin.Boolean?, dateStartFrom: kotlin.String?, dateStartTo: kotlin.String?, dateEndFrom: kotlin.String?, dateEndTo: kotlin.String?) : ApiResponse<CartCouponCount200Response?> {
        val localVariableConfig = cartCouponCountRequestConfig(storeId = storeId, avail = avail, dateStartFrom = dateStartFrom, dateStartTo = dateStartTo, dateEndFrom = dateEndFrom, dateEndTo = dateEndTo)

        return request<Unit, CartCouponCount200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartCouponCount
     *
     * @param storeId Store Id (optional)
     * @param avail Defines category&#39;s visibility status (optional, default to true)
     * @param dateStartFrom Filter entity by date_start (greater or equal) (optional)
     * @param dateStartTo Filter entity by date_start (less or equal) (optional)
     * @param dateEndFrom Filter entity by date_end (greater or equal) (optional)
     * @param dateEndTo Filter entity by date_end (less or equal) (optional)
     * @return RequestConfig
     */
    fun cartCouponCountRequestConfig(storeId: kotlin.String?, avail: kotlin.Boolean?, dateStartFrom: kotlin.String?, dateStartTo: kotlin.String?, dateEndFrom: kotlin.String?, dateEndTo: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
                if (dateStartFrom != null) {
                    put("date_start_from", listOf(dateStartFrom.toString()))
                }
                if (dateStartTo != null) {
                    put("date_start_to", listOf(dateStartTo.toString()))
                }
                if (dateEndFrom != null) {
                    put("date_end_from", listOf(dateEndFrom.toString()))
                }
                if (dateEndTo != null) {
                    put("date_end_to", listOf(dateEndTo.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.coupon.count.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.coupon.delete
     * Delete coupon
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartCouponDelete(id: kotlin.String, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = cartCouponDeleteWithHttpInfo(id = id, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.coupon.delete
     * Delete coupon
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartCouponDeleteWithHttpInfo(id: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = cartCouponDeleteRequestConfig(id = id, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartCouponDelete
     *
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun cartCouponDeleteRequestConfig(id: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/cart.coupon.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.coupon.list
     * Get cart coupon discounts.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param couponsIds Filter coupons by ids (optional)
     * @param storeId Filter coupons by store id (optional)
     * @param langId Language id (optional)
     * @param avail Filter coupons by avail status (optional)
     * @param dateStartFrom Filter entity by date_start (greater or equal) (optional)
     * @param dateStartTo Filter entity by date_start (less or equal) (optional)
     * @param dateEndFrom Filter entity by date_end (greater or equal) (optional)
     * @param dateEndTo Filter entity by date_end (less or equal) (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,code,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseCartCouponList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartCouponList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, couponsIds: kotlin.String? = null, storeId: kotlin.String? = null, langId: kotlin.String? = null, avail: kotlin.Boolean? = null, dateStartFrom: kotlin.String? = null, dateStartTo: kotlin.String? = null, dateEndFrom: kotlin.String? = null, dateEndTo: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "id,code,name,description", exclude: kotlin.String? = null) : ModelResponseCartCouponList {
        val localVarResponse = cartCouponListWithHttpInfo(start = start, count = count, pageCursor = pageCursor, couponsIds = couponsIds, storeId = storeId, langId = langId, avail = avail, dateStartFrom = dateStartFrom, dateStartTo = dateStartTo, dateEndFrom = dateEndFrom, dateEndTo = dateEndTo, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCartCouponList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.coupon.list
     * Get cart coupon discounts.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param couponsIds Filter coupons by ids (optional)
     * @param storeId Filter coupons by store id (optional)
     * @param langId Language id (optional)
     * @param avail Filter coupons by avail status (optional)
     * @param dateStartFrom Filter entity by date_start (greater or equal) (optional)
     * @param dateStartTo Filter entity by date_start (less or equal) (optional)
     * @param dateEndFrom Filter entity by date_end (greater or equal) (optional)
     * @param dateEndTo Filter entity by date_end (less or equal) (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,code,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseCartCouponList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartCouponListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, couponsIds: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, avail: kotlin.Boolean?, dateStartFrom: kotlin.String?, dateStartTo: kotlin.String?, dateEndFrom: kotlin.String?, dateEndTo: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseCartCouponList?> {
        val localVariableConfig = cartCouponListRequestConfig(start = start, count = count, pageCursor = pageCursor, couponsIds = couponsIds, storeId = storeId, langId = langId, avail = avail, dateStartFrom = dateStartFrom, dateStartTo = dateStartTo, dateEndFrom = dateEndFrom, dateEndTo = dateEndTo, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseCartCouponList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartCouponList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param couponsIds Filter coupons by ids (optional)
     * @param storeId Filter coupons by store id (optional)
     * @param langId Language id (optional)
     * @param avail Filter coupons by avail status (optional)
     * @param dateStartFrom Filter entity by date_start (greater or equal) (optional)
     * @param dateStartTo Filter entity by date_start (less or equal) (optional)
     * @param dateEndFrom Filter entity by date_end (greater or equal) (optional)
     * @param dateEndTo Filter entity by date_end (less or equal) (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,code,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun cartCouponListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, couponsIds: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, avail: kotlin.Boolean?, dateStartFrom: kotlin.String?, dateStartTo: kotlin.String?, dateEndFrom: kotlin.String?, dateEndTo: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (couponsIds != null) {
                    put("coupons_ids", listOf(couponsIds.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (avail != null) {
                    put("avail", listOf(avail.toString()))
                }
                if (dateStartFrom != null) {
                    put("date_start_from", listOf(dateStartFrom.toString()))
                }
                if (dateStartTo != null) {
                    put("date_start_to", listOf(dateStartTo.toString()))
                }
                if (dateEndFrom != null) {
                    put("date_end_from", listOf(dateEndFrom.toString()))
                }
                if (dateEndTo != null) {
                    put("date_end_to", listOf(dateEndTo.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.coupon.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.delete
     * Remove store from API2Cart
     * @param deleteBridge Identifies if there is a necessity to delete bridge (optional, default to true)
     * @return CartDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartDelete(deleteBridge: kotlin.Boolean? = true) : CartDelete200Response {
        val localVarResponse = cartDeleteWithHttpInfo(deleteBridge = deleteBridge)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.delete
     * Remove store from API2Cart
     * @param deleteBridge Identifies if there is a necessity to delete bridge (optional, default to true)
     * @return ApiResponse<CartDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartDeleteWithHttpInfo(deleteBridge: kotlin.Boolean?) : ApiResponse<CartDelete200Response?> {
        val localVariableConfig = cartDeleteRequestConfig(deleteBridge = deleteBridge)

        return request<Unit, CartDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartDelete
     *
     * @param deleteBridge Identifies if there is a necessity to delete bridge (optional, default to true)
     * @return RequestConfig
     */
    fun cartDeleteRequestConfig(deleteBridge: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deleteBridge != null) {
                    put("delete_bridge", listOf(deleteBridge.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/cart.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.giftcard.add
     * Use this method to create a gift card for a specified amount.
     * @param amount Defines the gift card amount value.
     * @param code Gift card code (optional)
     * @param ownerEmail Gift card owner email (optional)
     * @param recipientEmail Gift card recipient email (optional)
     * @param recipientName Gift card recipient name (optional)
     * @param ownerName Gift card owner name (optional)
     * @return CartGiftcardAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartGiftcardAdd(amount: java.math.BigDecimal, code: kotlin.String? = null, ownerEmail: kotlin.String? = null, recipientEmail: kotlin.String? = null, recipientName: kotlin.String? = null, ownerName: kotlin.String? = null) : CartGiftcardAdd200Response {
        val localVarResponse = cartGiftcardAddWithHttpInfo(amount = amount, code = code, ownerEmail = ownerEmail, recipientEmail = recipientEmail, recipientName = recipientName, ownerName = ownerName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartGiftcardAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.giftcard.add
     * Use this method to create a gift card for a specified amount.
     * @param amount Defines the gift card amount value.
     * @param code Gift card code (optional)
     * @param ownerEmail Gift card owner email (optional)
     * @param recipientEmail Gift card recipient email (optional)
     * @param recipientName Gift card recipient name (optional)
     * @param ownerName Gift card owner name (optional)
     * @return ApiResponse<CartGiftcardAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartGiftcardAddWithHttpInfo(amount: java.math.BigDecimal, code: kotlin.String?, ownerEmail: kotlin.String?, recipientEmail: kotlin.String?, recipientName: kotlin.String?, ownerName: kotlin.String?) : ApiResponse<CartGiftcardAdd200Response?> {
        val localVariableConfig = cartGiftcardAddRequestConfig(amount = amount, code = code, ownerEmail = ownerEmail, recipientEmail = recipientEmail, recipientName = recipientName, ownerName = ownerName)

        return request<Unit, CartGiftcardAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartGiftcardAdd
     *
     * @param amount Defines the gift card amount value.
     * @param code Gift card code (optional)
     * @param ownerEmail Gift card owner email (optional)
     * @param recipientEmail Gift card recipient email (optional)
     * @param recipientName Gift card recipient name (optional)
     * @param ownerName Gift card owner name (optional)
     * @return RequestConfig
     */
    fun cartGiftcardAddRequestConfig(amount: java.math.BigDecimal, code: kotlin.String?, ownerEmail: kotlin.String?, recipientEmail: kotlin.String?, recipientName: kotlin.String?, ownerName: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("amount", listOf(amount.toString()))
                if (code != null) {
                    put("code", listOf(code.toString()))
                }
                if (ownerEmail != null) {
                    put("owner_email", listOf(ownerEmail.toString()))
                }
                if (recipientEmail != null) {
                    put("recipient_email", listOf(recipientEmail.toString()))
                }
                if (recipientName != null) {
                    put("recipient_name", listOf(recipientName.toString()))
                }
                if (ownerName != null) {
                    put("owner_name", listOf(ownerName.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cart.giftcard.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.giftcard.count
     * Get gift cards count.
     * @param storeId Store Id (optional)
     * @return CartGiftcardCount200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartGiftcardCount(storeId: kotlin.String? = null) : CartGiftcardCount200Response {
        val localVarResponse = cartGiftcardCountWithHttpInfo(storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartGiftcardCount200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.giftcard.count
     * Get gift cards count.
     * @param storeId Store Id (optional)
     * @return ApiResponse<CartGiftcardCount200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartGiftcardCountWithHttpInfo(storeId: kotlin.String?) : ApiResponse<CartGiftcardCount200Response?> {
        val localVariableConfig = cartGiftcardCountRequestConfig(storeId = storeId)

        return request<Unit, CartGiftcardCount200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartGiftcardCount
     *
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun cartGiftcardCountRequestConfig(storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.giftcard.count.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.giftcard.delete
     * Delete giftcard
     * @param id Entity id
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartGiftcardDelete(id: kotlin.String) : AttributeDelete200Response {
        val localVarResponse = cartGiftcardDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.giftcard.delete
     * Delete giftcard
     * @param id Entity id
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartGiftcardDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = cartGiftcardDeleteRequestConfig(id = id)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartGiftcardDelete
     *
     * @param id Entity id
     * @return RequestConfig
     */
    fun cartGiftcardDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/cart.giftcard.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.giftcard.list
     * Get gift cards list.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,code,name")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseCartGiftCardList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartGiftcardList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, storeId: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "id,code,name", exclude: kotlin.String? = null) : ModelResponseCartGiftCardList {
        val localVarResponse = cartGiftcardListWithHttpInfo(start = start, count = count, pageCursor = pageCursor, storeId = storeId, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCartGiftCardList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.giftcard.list
     * Get gift cards list.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,code,name")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseCartGiftCardList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartGiftcardListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, storeId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseCartGiftCardList?> {
        val localVariableConfig = cartGiftcardListRequestConfig(start = start, count = count, pageCursor = pageCursor, storeId = storeId, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseCartGiftCardList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartGiftcardList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,code,name")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun cartGiftcardListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, storeId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.giftcard.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.info
     * This method allows you to get various information about the store, including a list of stores (in the case of a multistore configuration), a list of supported languages, currencies, carriers, warehouses, and many other information. This information contains data that is relatively stable and rarely changes, so API2Cart can cache certain data to reduce the load on the store and speed up the execution of the request. We also recommend that you cache the response of this method on your side to save requests. If you need to clear the cache for a specific store, then use the cart.validate method.
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "store_name,store_url,db_prefix")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return CartInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartInfo(storeId: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "store_name,store_url,db_prefix", exclude: kotlin.String? = null) : CartInfo200Response {
        val localVarResponse = cartInfoWithHttpInfo(storeId = storeId, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.info
     * This method allows you to get various information about the store, including a list of stores (in the case of a multistore configuration), a list of supported languages, currencies, carriers, warehouses, and many other information. This information contains data that is relatively stable and rarely changes, so API2Cart can cache certain data to reduce the load on the store and speed up the execution of the request. We also recommend that you cache the response of this method on your side to save requests. If you need to clear the cache for a specific store, then use the cart.validate method.
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "store_name,store_url,db_prefix")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<CartInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartInfoWithHttpInfo(storeId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<CartInfo200Response?> {
        val localVariableConfig = cartInfoRequestConfig(storeId = storeId, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, CartInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartInfo
     *
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "store_name,store_url,db_prefix")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun cartInfoRequestConfig(storeId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.info.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.meta_data.list
     * Using this method, you can get a list of metadata for various entities (products, options, customers, orders). Usually this is data created by third-party plugins.
     * @param entityId Entity Id
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param entity Entity (optional, default to "product")
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param key Key (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "key,value")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseCartMetaDataList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartMetaDataList(entityId: kotlin.String, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, entity: kotlin.String? = "product", storeId: kotlin.String? = null, langId: kotlin.String? = null, key: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "key,value", exclude: kotlin.String? = null) : ModelResponseCartMetaDataList {
        val localVarResponse = cartMetaDataListWithHttpInfo(entityId = entityId, count = count, pageCursor = pageCursor, entity = entity, storeId = storeId, langId = langId, key = key, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCartMetaDataList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.meta_data.list
     * Using this method, you can get a list of metadata for various entities (products, options, customers, orders). Usually this is data created by third-party plugins.
     * @param entityId Entity Id
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param entity Entity (optional, default to "product")
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param key Key (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "key,value")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseCartMetaDataList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartMetaDataListWithHttpInfo(entityId: kotlin.String, count: kotlin.Int?, pageCursor: kotlin.String?, entity: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, key: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseCartMetaDataList?> {
        val localVariableConfig = cartMetaDataListRequestConfig(entityId = entityId, count = count, pageCursor = pageCursor, entity = entity, storeId = storeId, langId = langId, key = key, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseCartMetaDataList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartMetaDataList
     *
     * @param entityId Entity Id
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param entity Entity (optional, default to "product")
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @param key Key (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "key,value")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun cartMetaDataListRequestConfig(entityId: kotlin.String, count: kotlin.Int?, pageCursor: kotlin.String?, entity: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?, key: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                put("entity_id", listOf(entityId.toString()))
                if (entity != null) {
                    put("entity", listOf(entity.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
                if (key != null) {
                    put("key", listOf(key.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.meta_data.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.meta_data.set
     * Set meta data for a specific entity
     * @param entityId Entity Id
     * @param key Key
     * @param `value` Value
     * @param namespace Metafield namespace
     * @param entity Entity (optional, default to "product")
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return AttributeAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartMetaDataSet(entityId: kotlin.String, key: kotlin.String, `value`: kotlin.String, namespace: kotlin.String, entity: kotlin.String? = "product", storeId: kotlin.String? = null, langId: kotlin.String? = null) : AttributeAdd200Response {
        val localVarResponse = cartMetaDataSetWithHttpInfo(entityId = entityId, key = key, `value` = `value`, namespace = namespace, entity = entity, storeId = storeId, langId = langId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.meta_data.set
     * Set meta data for a specific entity
     * @param entityId Entity Id
     * @param key Key
     * @param `value` Value
     * @param namespace Metafield namespace
     * @param entity Entity (optional, default to "product")
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return ApiResponse<AttributeAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartMetaDataSetWithHttpInfo(entityId: kotlin.String, key: kotlin.String, `value`: kotlin.String, namespace: kotlin.String, entity: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?) : ApiResponse<AttributeAdd200Response?> {
        val localVariableConfig = cartMetaDataSetRequestConfig(entityId = entityId, key = key, `value` = `value`, namespace = namespace, entity = entity, storeId = storeId, langId = langId)

        return request<Unit, AttributeAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartMetaDataSet
     *
     * @param entityId Entity Id
     * @param key Key
     * @param `value` Value
     * @param namespace Metafield namespace
     * @param entity Entity (optional, default to "product")
     * @param storeId Store Id (optional)
     * @param langId Language id (optional)
     * @return RequestConfig
     */
    fun cartMetaDataSetRequestConfig(entityId: kotlin.String, key: kotlin.String, `value`: kotlin.String, namespace: kotlin.String, entity: kotlin.String?, storeId: kotlin.String?, langId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("entity_id", listOf(entityId.toString()))
                put("key", listOf(key.toString()))
                put("value", listOf(`value`.toString()))
                put("namespace", listOf(namespace.toString()))
                if (entity != null) {
                    put("entity", listOf(entity.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (langId != null) {
                    put("lang_id", listOf(langId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cart.meta_data.set.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.meta_data.unset
     * Unset meta data for a specific entity
     * @param entityId Entity Id
     * @param key Key
     * @param id Entity id
     * @param entity Entity (optional, default to "product")
     * @param storeId Store Id (optional)
     * @return BasketLiveShippingServiceDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartMetaDataUnset(entityId: kotlin.String, key: kotlin.String, id: kotlin.String, entity: kotlin.String? = "product", storeId: kotlin.String? = null) : BasketLiveShippingServiceDelete200Response {
        val localVarResponse = cartMetaDataUnsetWithHttpInfo(entityId = entityId, key = key, id = id, entity = entity, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BasketLiveShippingServiceDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.meta_data.unset
     * Unset meta data for a specific entity
     * @param entityId Entity Id
     * @param key Key
     * @param id Entity id
     * @param entity Entity (optional, default to "product")
     * @param storeId Store Id (optional)
     * @return ApiResponse<BasketLiveShippingServiceDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartMetaDataUnsetWithHttpInfo(entityId: kotlin.String, key: kotlin.String, id: kotlin.String, entity: kotlin.String?, storeId: kotlin.String?) : ApiResponse<BasketLiveShippingServiceDelete200Response?> {
        val localVariableConfig = cartMetaDataUnsetRequestConfig(entityId = entityId, key = key, id = id, entity = entity, storeId = storeId)

        return request<Unit, BasketLiveShippingServiceDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartMetaDataUnset
     *
     * @param entityId Entity Id
     * @param key Key
     * @param id Entity id
     * @param entity Entity (optional, default to "product")
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun cartMetaDataUnsetRequestConfig(entityId: kotlin.String, key: kotlin.String, id: kotlin.String, entity: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("entity_id", listOf(entityId.toString()))
                put("key", listOf(key.toString()))
                put("id", listOf(id.toString()))
                if (entity != null) {
                    put("entity", listOf(entity.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/cart.meta_data.unset.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.methods
     * Returns a list of supported API methods.
     * @return CartMethods200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartMethods() : CartMethods200Response {
        val localVarResponse = cartMethodsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartMethods200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.methods
     * Returns a list of supported API methods.
     * @return ApiResponse<CartMethods200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartMethodsWithHttpInfo() : ApiResponse<CartMethods200Response?> {
        val localVariableConfig = cartMethodsRequestConfig()

        return request<Unit, CartMethods200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartMethods
     *
     * @return RequestConfig
     */
    fun cartMethodsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.methods.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.plugin.list
     * Get a list of third-party plugins installed on the store.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param storeId Store Id (optional)
     * @return CartPluginList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartPluginList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, storeId: kotlin.String? = null) : CartPluginList200Response {
        val localVarResponse = cartPluginListWithHttpInfo(start = start, count = count, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartPluginList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.plugin.list
     * Get a list of third-party plugins installed on the store.
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param storeId Store Id (optional)
     * @return ApiResponse<CartPluginList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartPluginListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, storeId: kotlin.String?) : ApiResponse<CartPluginList200Response?> {
        val localVariableConfig = cartPluginListRequestConfig(start = start, count = count, storeId = storeId)

        return request<Unit, CartPluginList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartPluginList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun cartPluginListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.plugin.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.script.add
     * Add new script to the storefront
     * @param name The user-friendly script name (optional)
     * @param description The user-friendly description (optional)
     * @param html An html string containing exactly one &#x60;script&#x60; tag. (optional)
     * @param src The URL of the remote script (optional)
     * @param loadMethod The load method to use for the script (optional)
     * @param scope The page or pages on the online store where the script should be included (optional, default to "storefront")
     * @param events Event for run scripts (optional)
     * @param storeId Store Id (optional)
     * @return CartScriptAdd200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartScriptAdd(name: kotlin.String? = null, description: kotlin.String? = null, html: kotlin.String? = null, src: kotlin.String? = null, loadMethod: kotlin.String? = null, scope: kotlin.String? = "storefront", events: kotlin.String? = null, storeId: kotlin.String? = null) : CartScriptAdd200Response {
        val localVarResponse = cartScriptAddWithHttpInfo(name = name, description = description, html = html, src = src, loadMethod = loadMethod, scope = scope, events = events, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartScriptAdd200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.script.add
     * Add new script to the storefront
     * @param name The user-friendly script name (optional)
     * @param description The user-friendly description (optional)
     * @param html An html string containing exactly one &#x60;script&#x60; tag. (optional)
     * @param src The URL of the remote script (optional)
     * @param loadMethod The load method to use for the script (optional)
     * @param scope The page or pages on the online store where the script should be included (optional, default to "storefront")
     * @param events Event for run scripts (optional)
     * @param storeId Store Id (optional)
     * @return ApiResponse<CartScriptAdd200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartScriptAddWithHttpInfo(name: kotlin.String?, description: kotlin.String?, html: kotlin.String?, src: kotlin.String?, loadMethod: kotlin.String?, scope: kotlin.String?, events: kotlin.String?, storeId: kotlin.String?) : ApiResponse<CartScriptAdd200Response?> {
        val localVariableConfig = cartScriptAddRequestConfig(name = name, description = description, html = html, src = src, loadMethod = loadMethod, scope = scope, events = events, storeId = storeId)

        return request<Unit, CartScriptAdd200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartScriptAdd
     *
     * @param name The user-friendly script name (optional)
     * @param description The user-friendly description (optional)
     * @param html An html string containing exactly one &#x60;script&#x60; tag. (optional)
     * @param src The URL of the remote script (optional)
     * @param loadMethod The load method to use for the script (optional)
     * @param scope The page or pages on the online store where the script should be included (optional, default to "storefront")
     * @param events Event for run scripts (optional)
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun cartScriptAddRequestConfig(name: kotlin.String?, description: kotlin.String?, html: kotlin.String?, src: kotlin.String?, loadMethod: kotlin.String?, scope: kotlin.String?, events: kotlin.String?, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (html != null) {
                    put("html", listOf(html.toString()))
                }
                if (src != null) {
                    put("src", listOf(src.toString()))
                }
                if (loadMethod != null) {
                    put("load_method", listOf(loadMethod.toString()))
                }
                if (scope != null) {
                    put("scope", listOf(scope.toString()))
                }
                if (events != null) {
                    put("events", listOf(events.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/cart.script.add.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.script.delete
     * Remove script from the storefront
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return AttributeDelete200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartScriptDelete(id: kotlin.String, storeId: kotlin.String? = null) : AttributeDelete200Response {
        val localVarResponse = cartScriptDeleteWithHttpInfo(id = id, storeId = storeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AttributeDelete200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.script.delete
     * Remove script from the storefront
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return ApiResponse<AttributeDelete200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartScriptDeleteWithHttpInfo(id: kotlin.String, storeId: kotlin.String?) : ApiResponse<AttributeDelete200Response?> {
        val localVariableConfig = cartScriptDeleteRequestConfig(id = id, storeId = storeId)

        return request<Unit, AttributeDelete200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartScriptDelete
     *
     * @param id Entity id
     * @param storeId Store Id (optional)
     * @return RequestConfig
     */
    fun cartScriptDeleteRequestConfig(id: kotlin.String, storeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("id", listOf(id.toString()))
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/cart.script.delete.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.script.list
     * Get scripts installed to the storefront
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param scriptIds Retrieves only scripts with specific ids (optional)
     * @param storeId Store Id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseCartScriptList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartScriptList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, pageCursor: kotlin.String? = null, scriptIds: kotlin.String? = null, storeId: kotlin.String? = null, createdFrom: kotlin.String? = null, createdTo: kotlin.String? = null, modifiedFrom: kotlin.String? = null, modifiedTo: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "id,name,description", exclude: kotlin.String? = null) : ModelResponseCartScriptList {
        val localVarResponse = cartScriptListWithHttpInfo(start = start, count = count, pageCursor = pageCursor, scriptIds = scriptIds, storeId = storeId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCartScriptList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.script.list
     * Get scripts installed to the storefront
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param scriptIds Retrieves only scripts with specific ids (optional)
     * @param storeId Store Id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseCartScriptList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartScriptListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, scriptIds: kotlin.String?, storeId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseCartScriptList?> {
        val localVariableConfig = cartScriptListRequestConfig(start = start, count = count, pageCursor = pageCursor, scriptIds = scriptIds, storeId = storeId, createdFrom = createdFrom, createdTo = createdTo, modifiedFrom = modifiedFrom, modifiedTo = modifiedTo, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseCartScriptList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartScriptList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param pageCursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param scriptIds Retrieves only scripts with specific ids (optional)
     * @param storeId Store Id (optional)
     * @param createdFrom Retrieve entities from their creation date (optional)
     * @param createdTo Retrieve entities to their creation date (optional)
     * @param modifiedFrom Retrieve entities from their modification date (optional)
     * @param modifiedTo Retrieve entities to their modification date (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,description")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun cartScriptListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, pageCursor: kotlin.String?, scriptIds: kotlin.String?, storeId: kotlin.String?, createdFrom: kotlin.String?, createdTo: kotlin.String?, modifiedFrom: kotlin.String?, modifiedTo: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (pageCursor != null) {
                    put("page_cursor", listOf(pageCursor.toString()))
                }
                if (scriptIds != null) {
                    put("script_ids", listOf(scriptIds.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (createdFrom != null) {
                    put("created_from", listOf(createdFrom.toString()))
                }
                if (createdTo != null) {
                    put("created_to", listOf(createdTo.toString()))
                }
                if (modifiedFrom != null) {
                    put("modified_from", listOf(modifiedFrom.toString()))
                }
                if (modifiedTo != null) {
                    put("modified_to", listOf(modifiedTo.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.script.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.shipping_zones.list
     * Get list of shipping zones
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,enabled")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ModelResponseCartShippingZonesList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartShippingZonesList(start: kotlin.Int? = 0, count: kotlin.Int? = 10, storeId: kotlin.String? = null, responseFields: kotlin.String? = null, params: kotlin.String? = "id,name,enabled", exclude: kotlin.String? = null) : ModelResponseCartShippingZonesList {
        val localVarResponse = cartShippingZonesListWithHttpInfo(start = start, count = count, storeId = storeId, responseFields = responseFields, params = params, exclude = exclude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelResponseCartShippingZonesList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.shipping_zones.list
     * Get list of shipping zones
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,enabled")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return ApiResponse<ModelResponseCartShippingZonesList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartShippingZonesListWithHttpInfo(start: kotlin.Int?, count: kotlin.Int?, storeId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : ApiResponse<ModelResponseCartShippingZonesList?> {
        val localVariableConfig = cartShippingZonesListRequestConfig(start = start, count = count, storeId = storeId, responseFields = responseFields, params = params, exclude = exclude)

        return request<Unit, ModelResponseCartShippingZonesList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartShippingZonesList
     *
     * @param start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param storeId Store Id (optional)
     * @param responseFields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to "id,name,enabled")
     * @param exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @return RequestConfig
     */
    fun cartShippingZonesListRequestConfig(start: kotlin.Int?, count: kotlin.Int?, storeId: kotlin.String?, responseFields: kotlin.String?, params: kotlin.String?, exclude: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (storeId != null) {
                    put("store_id", listOf(storeId.toString()))
                }
                if (responseFields != null) {
                    put("response_fields", listOf(responseFields.toString()))
                }
                if (params != null) {
                    put("params", listOf(params.toString()))
                }
                if (exclude != null) {
                    put("exclude", listOf(exclude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.shipping_zones.list.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * cart.validate
     * This method clears the cache in API2Cart for a particular store and checks whether the connection to the store is available. Use this method if there have been any changes in the settings on the storе, for example, if a new plugin has been installed or removed.
     * @param validateVersion Specify if api2cart should validate cart version (optional, default to false)
     * @return CartValidate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cartValidate(validateVersion: kotlin.Boolean? = false) : CartValidate200Response {
        val localVarResponse = cartValidateWithHttpInfo(validateVersion = validateVersion)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CartValidate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * cart.validate
     * This method clears the cache in API2Cart for a particular store and checks whether the connection to the store is available. Use this method if there have been any changes in the settings on the storе, for example, if a new plugin has been installed or removed.
     * @param validateVersion Specify if api2cart should validate cart version (optional, default to false)
     * @return ApiResponse<CartValidate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cartValidateWithHttpInfo(validateVersion: kotlin.Boolean?) : ApiResponse<CartValidate200Response?> {
        val localVariableConfig = cartValidateRequestConfig(validateVersion = validateVersion)

        return request<Unit, CartValidate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cartValidate
     *
     * @param validateVersion Specify if api2cart should validate cart version (optional, default to false)
     * @return RequestConfig
     */
    fun cartValidateRequestConfig(validateVersion: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (validateVersion != null) {
                    put("validate_version", listOf(validateVersion.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/cart.validate.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
